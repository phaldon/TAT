<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TAT: TAT 命名空间参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TAT
   &#160;<span id="projectnumber">v0.1.0-rc.11</span>
   </div>
   <div id="projectbrief">TAT is A Tensor library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceTAT.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#func-members">函数</a> &#124;
<a href="#var-members">变量</a>  </div>
  <div class="headertitle">
<div class="title">TAT 命名空间参考</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceTAT.html" title="TAT is A Tensor library">TAT</a> is A <a class="el" href="structTAT_1_1Tensor.html" title="张量类型">Tensor</a> library  
<a href="namespaceTAT.html#details">更多...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1allocator__without__initialize.html">allocator_without_initialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">用于不初始化的<code>vector</code>的<code>allocator</code>, 仅用于张量数据的存储  <a href="structTAT_1_1allocator__without__initialize.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1bose__symmetry.html">bose_symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">玻色对称性的公有方法集, 并不存在  <a href="structTAT_1_1bose__symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1bose__symmetry__base.html">bose_symmetry_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">所有玻色对称性的基类, 用来判断一个类型是否是玻色对称性  <a href="structTAT_1_1bose__symmetry__base.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Core.html">Core</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录了张量的核心数据的类型, 核心数据指的是除了角标名称之外的信息, 包括边的形状, 以及张量内本身的数据  <a href="structTAT_1_1Core.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量的边的形状的类型, 是一个Symmetry到Size的映射表, 如果是费米对称性, 还会含有一个箭头方向  <a href="structTAT_1_1Edge.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1fake__map.html">fake_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">只有一个元素的假map  <a href="structTAT_1_1fake__map.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1fast__name__dataset__t.html">fast_name_dataset_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FastName使用的映射表类型  <a href="structTAT_1_1fast__name__dataset__t.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1FastName.html">FastName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">用于给张量的边命名的类型FastName, 新建FastName的时候可以选定标号, 也可以选定字符串作为名称, FastName将自动保证标号和名称的一一对应  <a href="structTAT_1_1FastName.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1fermi__symmetry.html">fermi_symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">费米对称性的公有方法集  <a href="structTAT_1_1fermi__symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1fermi__symmetry__base.html">fermi_symmetry_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">所有费米对称性的基类, 用来判断一个类型是否是费米对称性  <a href="structTAT_1_1fermi__symmetry__base.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1FermiEdge.html">FermiEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1FermiSymmetry.html">FermiSymmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">费米的无对称性  <a href="structTAT_1_1FermiSymmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1FermiU1Symmetry.html">FermiU1Symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">费米的U1对称性  <a href="structTAT_1_1FermiU1Symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1FermiZ2Symmetry.html">FermiZ2Symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">费米的Z2对称性  <a href="structTAT_1_1FermiZ2Symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1InternalName.html">InternalName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">对于每个将要被使用做Name的类型, 需要设置一部分保留类型  <a href="structTAT_1_1InternalName.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__bose__symmetry.html">is_bose_symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断一个类型是否是玻色对称性类型  <a href="structTAT_1_1is__bose__symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断是否是复数类型  <a href="structTAT_1_1is__complex.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__edge.html">is_edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断一个类型是否为Edge类型, 这里不认为map为引用的Edge类型为Edge  <a href="structTAT_1_1is__edge.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__fermi__symmetry.html">is_fermi_symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断一个类型是否是费米对称性类型  <a href="structTAT_1_1is__fermi__symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__name.html">is_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断一个类型是否可以作为Name  <a href="structTAT_1_1is__name.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__real.html">is_real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断是否是实数类型  <a href="structTAT_1_1is__real.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断一个类型是否是标量类型, 修复了<code>std::scalar</code>不能判断<code>std::complex</code>的问题  <a href="structTAT_1_1is__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1is__symmetry.html">is_symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断一个类型是否是对称性类型  <a href="structTAT_1_1is__symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1mpi__output__stream.html">mpi_output_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">对流进行包装, 包装后流只会从创建时指定的rank进程中输出  <a href="structTAT_1_1mpi__output__stream.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1mpi__t.html">mpi_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">一个mpi handler, 会在构造和析构时自动调用MPI_Init和MPI_Finalize, 且会获取Size和Rank信息  <a href="structTAT_1_1mpi__t.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1NameTraits.html">NameTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">对于每个将要被使用做Name的类型, 需要设置其输入输出方式  <a href="structTAT_1_1NameTraits.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1NameTraitsBase.html">NameTraitsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name的伪输出输出的默认函数, 里面含有四个无效的输出输出函数, 如果不覆盖, 则不能调用  <a href="structTAT_1_1NameTraitsBase.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1NoSymmetry.html">NoSymmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">无对称性  <a href="structTAT_1_1NoSymmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1real__base.html">real_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">取对应的实数类型, 在svd, norm等地方会用到  <a href="structTAT_1_1real__base.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Singular.html">Singular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量看成矩阵后做svd分解后得到的奇异值类型, 为对角矩阵形式的张量  <a href="structTAT_1_1Singular.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1symmetry__base.html">symmetry_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">所有对称性类型的基类, 用于判断一个类型是否是对称性类型  <a href="structTAT_1_1symmetry__base.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量类型  <a href="structTAT_1_1Tensor.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">计时器类型  <a href="structTAT_1_1timer.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1U1Symmetry.html">U1Symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">U1对称性  <a href="structTAT_1_1U1Symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1UnixColorCode.html">UnixColorCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">一个控制屏幕字体色彩的简单类型  <a href="structTAT_1_1UnixColorCode.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">尽可能不做初始化的vector容器  <a href="structTAT_1_1vector.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Z2Symmetry.html">Z2Symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Z2对称性  <a href="structTAT_1_1Z2Symmetry.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:ga62eb09d4bc76da9469d3a43882ca295a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga62eb09d4bc76da9469d3a43882ca295a">Rank</a> = unsigned short</td></tr>
<tr class="memdesc:ga62eb09d4bc76da9469d3a43882ca295a"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量的秩的类型  <a href="group__Miscellaneous.html#ga62eb09d4bc76da9469d3a43882ca295a">更多...</a><br /></td></tr>
<tr class="separator:ga62eb09d4bc76da9469d3a43882ca295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50ae59af1a35e2ecec08941c3d1115d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gac50ae59af1a35e2ecec08941c3d1115d">Nums</a> = unsigned int</td></tr>
<tr class="memdesc:gac50ae59af1a35e2ecec08941c3d1115d"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量分块数目和一个边上对称性数目的类型  <a href="group__Miscellaneous.html#gac50ae59af1a35e2ecec08941c3d1115d">更多...</a><br /></td></tr>
<tr class="separator:gac50ae59af1a35e2ecec08941c3d1115d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac705eedd6237ac6373746e8d473fef14"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> = unsigned long</td></tr>
<tr class="memdesc:gac705eedd6237ac6373746e8d473fef14"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量数据维度大小和数据本身大小的类型  <a href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">更多...</a><br /></td></tr>
<tr class="separator:gac705eedd6237ac6373746e8d473fef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0315e334e454cc7330c18d2cbd677b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga9f0315e334e454cc7330c18d2cbd677b">Z2</a> = bool</td></tr>
<tr class="memdesc:ga9f0315e334e454cc7330c18d2cbd677b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Z2对称性的类型  <a href="group__Miscellaneous.html#ga9f0315e334e454cc7330c18d2cbd677b">更多...</a><br /></td></tr>
<tr class="separator:ga9f0315e334e454cc7330c18d2cbd677b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649dcaf16448df0d8f4059620a839685"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga649dcaf16448df0d8f4059620a839685">U1</a> = int</td></tr>
<tr class="memdesc:ga649dcaf16448df0d8f4059620a839685"><td class="mdescLeft">&#160;</td><td class="mdescRight">U1对称性的类型  <a href="group__Miscellaneous.html#ga649dcaf16448df0d8f4059620a839685">更多...</a><br /></td></tr>
<tr class="separator:ga649dcaf16448df0d8f4059620a839685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2caf6417e000ace96d8b9e2c495ac49"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gad2caf6417e000ace96d8b9e2c495ac49">Fermi</a> = short</td></tr>
<tr class="memdesc:gad2caf6417e000ace96d8b9e2c495ac49"><td class="mdescLeft">&#160;</td><td class="mdescRight">费米子数目的类型  <a href="group__Miscellaneous.html#gad2caf6417e000ace96d8b9e2c495ac49">更多...</a><br /></td></tr>
<tr class="separator:gad2caf6417e000ace96d8b9e2c495ac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78326bee7cc963cd2d165718de5c0465"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a> = bool</td></tr>
<tr class="memdesc:ga78326bee7cc963cd2d165718de5c0465"><td class="mdescLeft">&#160;</td><td class="mdescRight">费米箭头方向的类型, <code>false</code>和<code>true</code>分别表示出入  <a href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">更多...</a><br /></td></tr>
<tr class="separator:ga78326bee7cc963cd2d165718de5c0465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03fb813e3f2c8c1633ebe103894051a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga03fb813e3f2c8c1633ebe103894051a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga03fb813e3f2c8c1633ebe103894051a3">real_base_t</a> = typename <a class="el" href="structTAT_1_1real__base.html">real_base</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ga03fb813e3f2c8c1633ebe103894051a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3ab11031b46ba215af060f57b3145b"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry , bool is_pointer&gt; </td></tr>
<tr class="memitem:ga8a3ab11031b46ba215af060f57b3145b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Edge.html#ga8a3ab11031b46ba215af060f57b3145b">EdgeBase</a> = std::conditional_t&lt; <a class="el" href="group__Symmetry.html#gaa34e28a8b930984824c1825b840078e7">is_fermi_symmetry_v</a>&lt; Symmetry &gt;, <a class="el" href="structTAT_1_1FermiEdge.html">FermiEdge</a>&lt; Symmetry, is_pointer &gt;, <a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a>&lt; Symmetry, is_pointer &gt; &gt;</td></tr>
<tr class="separator:ga8a3ab11031b46ba215af060f57b3145b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21b38ad84427829832b86083f28b8cc"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry &gt; </td></tr>
<tr class="memitem:gae21b38ad84427829832b86083f28b8cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Edge.html#gae21b38ad84427829832b86083f28b8cc">EdgePointer</a> = <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry, true &gt;</td></tr>
<tr class="memdesc:gae21b38ad84427829832b86083f28b8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">中间处理中常用到的数据类型, 类似Edge但是其中对称性值到子边长的映射表为指针  <a href="group__Edge.html#gae21b38ad84427829832b86083f28b8cc">更多...</a><br /></td></tr>
<tr class="separator:gae21b38ad84427829832b86083f28b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0032f910fcdb4853bc83a17a7d1f48d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Name.html#ga0032f910fcdb4853bc83a17a7d1f48d9">DefaultName</a> = <a class="el" href="structTAT_1_1FastName.html">FastName</a></td></tr>
<tr class="memdesc:ga0032f910fcdb4853bc83a17a7d1f48d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structTAT_1_1Tensor.html" title="张量类型">Tensor</a></code>默认使用的<code>Name</code>, 如果没有定义宏<code>TAT_USE_SIMPLE_NAME</code>则为<code><a class="el" href="structTAT_1_1FastName.html" title="用于给张量的边命名的类型FastName, 新建FastName的时候可以选定标号, 也可以选定字符串作为名称, FastName将自动保证标号和名称的一一对应">FastName</a></code>, 否则为<code>std::string</code>  <a href="group__Name.html#ga0032f910fcdb4853bc83a17a7d1f48d9">更多...</a><br /></td></tr>
<tr class="separator:ga0032f910fcdb4853bc83a17a7d1f48d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772805fe85720057d8edb3a4ca39b32d"><td class="memTemplParams" colspan="2">template&lt;typename Name &gt; </td></tr>
<tr class="memitem:ga772805fe85720057d8edb3a4ca39b32d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Name.html#ga772805fe85720057d8edb3a4ca39b32d">name_out_operator</a> = std::ostream &amp;(*)(std::ostream &amp;, const Name &amp;)</td></tr>
<tr class="separator:ga772805fe85720057d8edb3a4ca39b32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e35da99049916e6f537c45c5bb66a3"><td class="memTemplParams" colspan="2">template&lt;typename Name &gt; </td></tr>
<tr class="memitem:ga45e35da99049916e6f537c45c5bb66a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Name.html#ga45e35da99049916e6f537c45c5bb66a3">name_in_operator</a> = std::istream &amp;(*)(std::istream &amp;, Name &amp;)</td></tr>
<tr class="separator:ga45e35da99049916e6f537c45c5bb66a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19aacb4ec6e5ad58c9caa334cd87d0fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timer.html#ga19aacb4ec6e5ad58c9caa334cd87d0fb">time_point</a> = std::chrono::high_resolution_clock::time_point</td></tr>
<tr class="separator:ga19aacb4ec6e5ad58c9caa334cd87d0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1bb116bf0e7bc355dd91cae68bdf50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timer.html#gaab1bb116bf0e7bc355dd91cae68bdf50">time_duration</a> = std::chrono::high_resolution_clock::duration</td></tr>
<tr class="separator:gaab1bb116bf0e7bc355dd91cae68bdf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de57c4ace04ef10b97897668a2a58aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timer.html#ga8de57c4ace04ef10b97897668a2a58aa">time_pair</a> = std::tuple&lt; <a class="el" href="group__Timer.html#ga19aacb4ec6e5ad58c9caa334cd87d0fb">time_point</a>, <a class="el" href="group__Timer.html#gaab1bb116bf0e7bc355dd91cae68bdf50">time_duration</a> &gt;</td></tr>
<tr class="separator:ga8de57c4ace04ef10b97897668a2a58aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:gad5dd219490b6003510d2b0146d5f8983"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:gad5dd219490b6003510d2b0146d5f8983"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gad5dd219490b6003510d2b0146d5f8983">operator==</a> (const <a class="el" href="structTAT_1_1fake__map.html">fake_map</a>&lt; Key, Value &gt; &amp;map_1, const <a class="el" href="structTAT_1_1fake__map.html">fake_map</a>&lt; Key, Value &gt; &amp;map_2)</td></tr>
<tr class="separator:gad5dd219490b6003510d2b0146d5f8983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ea4e493bbb7652de12c3d152aaa184"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry , bool is_pointer&gt; </td></tr>
<tr class="memitem:ga55ea4e493bbb7652de12c3d152aaa184"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Edge.html#ga55ea4e493bbb7652de12c3d152aaa184">operator==</a> (const <a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a>&lt; Symmetry, is_pointer &gt; &amp;edge_1, const <a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a>&lt; Symmetry, is_pointer &gt; &amp;edge_2)</td></tr>
<tr class="separator:ga55ea4e493bbb7652de12c3d152aaa184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e4eaa44c78822b44ad772f7423b386"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry , bool is_pointer&gt; </td></tr>
<tr class="memitem:ga93e4eaa44c78822b44ad772f7423b386"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Edge.html#ga93e4eaa44c78822b44ad772f7423b386">operator==</a> (const <a class="el" href="structTAT_1_1FermiEdge.html">FermiEdge</a>&lt; Symmetry, is_pointer &gt; &amp;edge_1, const <a class="el" href="structTAT_1_1FermiEdge.html">FermiEdge</a>&lt; Symmetry, is_pointer &gt; &amp;edge_2)</td></tr>
<tr class="separator:ga93e4eaa44c78822b44ad772f7423b386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6fee850c1a102e9a7ecfb9e645c082"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr class="memitem:ga4c6fee850c1a102e9a7ecfb9e645c082"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Edge.html#ga4c6fee850c1a102e9a7ecfb9e645c082">loop_edge</a> (const T *edges, const <a class="el" href="group__Miscellaneous.html#ga62eb09d4bc76da9469d3a43882ca295a">Rank</a> rank, F1 &amp;&amp;rank0, F2 &amp;&amp;dims0, F3 &amp;&amp;operate)</td></tr>
<tr class="memdesc:ga4c6fee850c1a102e9a7ecfb9e645c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">对一个边的形状列表进行枚举分块, 并做一些其他操作  <a href="group__Edge.html#ga4c6fee850c1a102e9a7ecfb9e645c082">更多...</a><br /></td></tr>
<tr class="separator:ga4c6fee850c1a102e9a7ecfb9e645c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceaf8873ee359da4ef77e670692a8d9a"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:gaceaf8873ee359da4ef77e670692a8d9a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#gaceaf8873ee359da4ef77e670692a8d9a">print_complex</a> (std::ostream &amp;out, const std::complex&lt; ScalarType &gt; &amp;value)</td></tr>
<tr class="separator:gaceaf8873ee359da4ef77e670692a8d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d67643c94e17fc4c0f8df2df1ecbdb"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:ga63d67643c94e17fc4c0f8df2df1ecbdb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga63d67643c94e17fc4c0f8df2df1ecbdb">print_complex</a> (std::ostream &amp;&amp;out, const std::complex&lt; ScalarType &gt; &amp;value)</td></tr>
<tr class="separator:ga63d67643c94e17fc4c0f8df2df1ecbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac9b81e078727a0e673cb5702be8e582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaac9b81e078727a0e673cb5702be8e582">ignore_util</a> (std::istream &amp;in, char end)</td></tr>
<tr class="separator:gaac9b81e078727a0e673cb5702be8e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b5d948b0140752bd6d0163f6f2afdb"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:ga64b5d948b0140752bd6d0163f6f2afdb"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga64b5d948b0140752bd6d0163f6f2afdb">scan_complex</a> (std::istream &amp;in, std::complex&lt; ScalarType &gt; &amp;value)</td></tr>
<tr class="separator:ga64b5d948b0140752bd6d0163f6f2afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd316d9bd49251410293e11ce6d11b25"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:gafd316d9bd49251410293e11ce6d11b25"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#gafd316d9bd49251410293e11ce6d11b25">scan_complex</a> (std::istream &amp;&amp;in, std::complex&lt; ScalarType &gt; &amp;value)</td></tr>
<tr class="separator:gafd316d9bd49251410293e11ce6d11b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9b25458cc9c6ec62c9422a54bccb14"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_trivially_destructible_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga1c9b25458cc9c6ec62c9422a54bccb14"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1c9b25458cc9c6ec62c9422a54bccb14">operator&lt;</a> (std::ostream &amp;out, const T &amp;data)</td></tr>
<tr class="separator:ga1c9b25458cc9c6ec62c9422a54bccb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c258b3e38a3d1883ed876629b5572c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_trivially_destructible_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga65c258b3e38a3d1883ed876629b5572c"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga65c258b3e38a3d1883ed876629b5572c">operator&gt;</a> (std::istream &amp;in, T &amp;data)</td></tr>
<tr class="separator:ga65c258b3e38a3d1883ed876629b5572c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952791066c2d36cf8aec3550b3f09904"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga952791066c2d36cf8aec3550b3f09904">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1FastName.html">FastName</a> &amp;name)</td></tr>
<tr class="separator:ga952791066c2d36cf8aec3550b3f09904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9ccd9003087cc87d0f7595ac37a8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga0b9ccd9003087cc87d0f7595ac37a8a2">valid_name_character</a> (char c)</td></tr>
<tr class="separator:ga0b9ccd9003087cc87d0f7595ac37a8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa110d47ac565ae2779de3de5ff635c59"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaa110d47ac565ae2779de3de5ff635c59">scan_string_for_name</a> (std::istream &amp;in, std::string &amp;name)</td></tr>
<tr class="separator:gaa110d47ac565ae2779de3de5ff635c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df151abfc11c364fdad8b358b387a48"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1df151abfc11c364fdad8b358b387a48">scan_fastname_for_name</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1FastName.html">FastName</a> &amp;name)</td></tr>
<tr class="separator:ga1df151abfc11c364fdad8b358b387a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1ef7acbfcf1b7c788443771525392f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaec1ef7acbfcf1b7c788443771525392f">operator&lt;</a> (std::ostream &amp;out, const std::string &amp;string)</td></tr>
<tr class="separator:gaec1ef7acbfcf1b7c788443771525392f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69eb5627e5ad9a2875696ee72587063"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gab69eb5627e5ad9a2875696ee72587063">operator&gt;</a> (std::istream &amp;in, std::string &amp;string)</td></tr>
<tr class="separator:gab69eb5627e5ad9a2875696ee72587063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7070bb9e74a4ac3d2428a2f3f1ea8f56"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , typename  = std::enable_if_t&lt;is_symmetry_v&lt;Key&gt; || is_symmetry_vector_v&lt;Key&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga7070bb9e74a4ac3d2428a2f3f1ea8f56"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga7070bb9e74a4ac3d2428a2f3f1ea8f56">operator&lt;</a> (std::ostream &amp;out, const std::map&lt; Key, Value &gt; &amp;map)</td></tr>
<tr class="separator:ga7070bb9e74a4ac3d2428a2f3f1ea8f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c77b3f2c21a8634622ae0c5745971c"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , typename  = std::enable_if_t&lt;is_symmetry_v&lt;Key&gt; || is_symmetry_vector_v&lt;Key&gt;&gt;&gt; </td></tr>
<tr class="memitem:gaa3c77b3f2c21a8634622ae0c5745971c"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#gaa3c77b3f2c21a8634622ae0c5745971c">operator&gt;</a> (std::istream &amp;in, std::map&lt; Key, Value &gt; &amp;map)</td></tr>
<tr class="separator:gaa3c77b3f2c21a8634622ae0c5745971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13002a177520161a55c46862200af0a7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename  = std::enable_if_t&lt;is_scalar_v&lt;T&gt; || is_edge_v&lt;T&gt; || is_symmetry_v&lt;T&gt; || is_name_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga13002a177520161a55c46862200af0a7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga13002a177520161a55c46862200af0a7">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;list)</td></tr>
<tr class="separator:ga13002a177520161a55c46862200af0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9929c09c801b973aa84e8e34f2a16301"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename  = std::enable_if_t&lt;is_scalar_v&lt;T&gt; || is_edge_v&lt;T&gt; || is_symmetry_v&lt;T&gt; || is_name_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga9929c09c801b973aa84e8e34f2a16301"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga9929c09c801b973aa84e8e34f2a16301">operator&gt;&gt;</a> (std::istream &amp;in, std::vector&lt; T, A &gt; &amp;list)</td></tr>
<tr class="separator:ga9929c09c801b973aa84e8e34f2a16301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f99d3e3cca0e0b82393647ace57160f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ga8f99d3e3cca0e0b82393647ace57160f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8f99d3e3cca0e0b82393647ace57160f">operator&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;list)</td></tr>
<tr class="separator:ga8f99d3e3cca0e0b82393647ace57160f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5afe3e6956ef596dcdd2bfba62d24f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ga5e5afe3e6956ef596dcdd2bfba62d24f"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga5e5afe3e6956ef596dcdd2bfba62d24f">operator&gt;</a> (std::istream &amp;in, std::vector&lt; T, A &gt; &amp;list)</td></tr>
<tr class="separator:ga5e5afe3e6956ef596dcdd2bfba62d24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd7daad5a8d7c39a0268b8cebe12497"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry &gt; </td></tr>
<tr class="memitem:ga8dd7daad5a8d7c39a0268b8cebe12497"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8dd7daad5a8d7c39a0268b8cebe12497">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry &gt; &amp;edge)</td></tr>
<tr class="separator:ga8dd7daad5a8d7c39a0268b8cebe12497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7344d49c8fd21291470fb5dd02e865"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry &gt; </td></tr>
<tr class="memitem:ga2c7344d49c8fd21291470fb5dd02e865"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga2c7344d49c8fd21291470fb5dd02e865">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry &gt; &amp;edge)</td></tr>
<tr class="separator:ga2c7344d49c8fd21291470fb5dd02e865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ab92707d9f192d2bfc240c4573996c"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry &gt; </td></tr>
<tr class="memitem:ga25ab92707d9f192d2bfc240c4573996c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga25ab92707d9f192d2bfc240c4573996c">operator&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry &gt; &amp;edge)</td></tr>
<tr class="separator:ga25ab92707d9f192d2bfc240c4573996c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8619114e5350c68b3dfc562b9b8c486d"><td class="memTemplParams" colspan="2">template&lt;typename Symmetry &gt; </td></tr>
<tr class="memitem:ga8619114e5350c68b3dfc562b9b8c486d"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8619114e5350c68b3dfc562b9b8c486d">operator&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry &gt; &amp;edge)</td></tr>
<tr class="separator:ga8619114e5350c68b3dfc562b9b8c486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47be5e58bb1a36620481498f29b448f0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga47be5e58bb1a36620481498f29b448f0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1NoSymmetry.html">NoSymmetry</a> &amp;)</td></tr>
<tr class="separator:ga47be5e58bb1a36620481498f29b448f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedff2ec69fef82663f17a6ef6e19f0a4"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaedff2ec69fef82663f17a6ef6e19f0a4">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1NoSymmetry.html">NoSymmetry</a> &amp;)</td></tr>
<tr class="separator:gaedff2ec69fef82663f17a6ef6e19f0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fd656cbc8af475f7ebf8e1e7bdffc4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gac5fd656cbc8af475f7ebf8e1e7bdffc4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1Z2Symmetry.html">Z2Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:gac5fd656cbc8af475f7ebf8e1e7bdffc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f188e411ffd0ff42823e648cb65b8ed"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1f188e411ffd0ff42823e648cb65b8ed">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1Z2Symmetry.html">Z2Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:ga1f188e411ffd0ff42823e648cb65b8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9143a1202c9e900920a486b49a6ab25d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga9143a1202c9e900920a486b49a6ab25d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1U1Symmetry.html">U1Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:ga9143a1202c9e900920a486b49a6ab25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881429f49e4c84b09742b7f3a9ff2185"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga881429f49e4c84b09742b7f3a9ff2185">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1U1Symmetry.html">U1Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:ga881429f49e4c84b09742b7f3a9ff2185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b76ac1de247c8ee0eeada7398c903a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga41b76ac1de247c8ee0eeada7398c903a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1FermiSymmetry.html">FermiSymmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:ga41b76ac1de247c8ee0eeada7398c903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50d6440baa78fcaa7fb8f1b32f84676"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaa50d6440baa78fcaa7fb8f1b32f84676">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1FermiSymmetry.html">FermiSymmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:gaa50d6440baa78fcaa7fb8f1b32f84676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ceb99be12f81ca836ab8cd22f3f09a7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8ceb99be12f81ca836ab8cd22f3f09a7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1FermiZ2Symmetry.html">FermiZ2Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:ga8ceb99be12f81ca836ab8cd22f3f09a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da47e1e52c64b2bb6a61678c49d8579"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8da47e1e52c64b2bb6a61678c49d8579">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1FermiZ2Symmetry.html">FermiZ2Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:ga8da47e1e52c64b2bb6a61678c49d8579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b0d6999e2f97d7f64f551ce14290c2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gac4b0d6999e2f97d7f64f551ce14290c2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1FermiU1Symmetry.html">FermiU1Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:gac4b0d6999e2f97d7f64f551ce14290c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff9d14dc7bec58b285dee64b39af399"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1ff9d14dc7bec58b285dee64b39af399">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1FermiU1Symmetry.html">FermiU1Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:ga1ff9d14dc7bec58b285dee64b39af399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2f55e19d46917363973d272e6695ff"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gacc2f55e19d46917363973d272e6695ff">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1UnixColorCode.html">UnixColorCode</a> &amp;value)</td></tr>
<tr class="separator:gacc2f55e19d46917363973d272e6695ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964ee34f8c6293ffadd3780dbc63480a"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga964ee34f8c6293ffadd3780dbc63480a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga964ee34f8c6293ffadd3780dbc63480a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;tensor)</td></tr>
<tr class="separator:ga964ee34f8c6293ffadd3780dbc63480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01053acb7e13b4999f2d3ecd37fdcfb2"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga01053acb7e13b4999f2d3ecd37fdcfb2"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga01053acb7e13b4999f2d3ecd37fdcfb2">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;tensor)</td></tr>
<tr class="separator:ga01053acb7e13b4999f2d3ecd37fdcfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f9e2503566fca132cf0b52c3f8fd9e"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:gae5f9e2503566fca132cf0b52c3f8fd9e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#gae5f9e2503566fca132cf0b52c3f8fd9e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType, Symmetry, Name &gt; &amp;singular)</td></tr>
<tr class="separator:gae5f9e2503566fca132cf0b52c3f8fd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d0a045e432640f9ed90a19b687e15cf"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga3d0a045e432640f9ed90a19b687e15cf"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga3d0a045e432640f9ed90a19b687e15cf">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType, Symmetry, Name &gt; &amp;singular)</td></tr>
<tr class="separator:ga3d0a045e432640f9ed90a19b687e15cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca1fe9214d19c2f6c6fbb40f4e2c6b7"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:gafca1fe9214d19c2f6c6fbb40f4e2c6b7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#gafca1fe9214d19c2f6c6fbb40f4e2c6b7">operator&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;tensor)</td></tr>
<tr class="separator:gafca1fe9214d19c2f6c6fbb40f4e2c6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb6edd0bdd17744301fe6cc48bab45f"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:gabbb6edd0bdd17744301fe6cc48bab45f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#gabbb6edd0bdd17744301fe6cc48bab45f">operator&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType, Symmetry, Name &gt; &amp;singular)</td></tr>
<tr class="separator:gabbb6edd0bdd17744301fe6cc48bab45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a686edada7118359a82fd7bcfdab84c"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga2a686edada7118359a82fd7bcfdab84c"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga2a686edada7118359a82fd7bcfdab84c">operator&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;tensor)</td></tr>
<tr class="separator:ga2a686edada7118359a82fd7bcfdab84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f41acdab7665fe4e5bb7c95a0559ca2"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga2f41acdab7665fe4e5bb7c95a0559ca2"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga2f41acdab7665fe4e5bb7c95a0559ca2">operator&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType, Symmetry, Name &gt; &amp;singular)</td></tr>
<tr class="separator:ga2f41acdab7665fe4e5bb7c95a0559ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbd29a9b91f0efc7936e8473fb3580b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gabdbd29a9b91f0efc7936e8473fb3580b">operator&lt;</a> (std::ostream &amp;out, const <a class="el" href="structTAT_1_1fast__name__dataset__t.html">fast_name_dataset_t</a> &amp;dataset)</td></tr>
<tr class="separator:gabdbd29a9b91f0efc7936e8473fb3580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9c1546c4a4e88f73be10588758dfdc"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gafb9c1546c4a4e88f73be10588758dfdc">operator&gt;</a> (std::istream &amp;in, <a class="el" href="structTAT_1_1fast__name__dataset__t.html">fast_name_dataset_t</a> &amp;dataset)</td></tr>
<tr class="separator:gafb9c1546c4a4e88f73be10588758dfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7586919a450dda89c084b464ef3feeed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga7586919a450dda89c084b464ef3feeed">load_fast_name_dataset</a> (const std::string &amp;input)</td></tr>
<tr class="separator:ga7586919a450dda89c084b464ef3feeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1b147b866b0fd6afe7b44787be2993"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga3e1b147b866b0fd6afe7b44787be2993">dump_fast_name_dataset</a> ()</td></tr>
<tr class="separator:ga3e1b147b866b0fd6afe7b44787be2993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90274dfa0c2cf49e3b7cffb580fd85be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga90274dfa0c2cf49e3b7cffb580fd85be"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga90274dfa0c2cf49e3b7cffb580fd85be">operator&gt;</a> (std::istream &amp;&amp;in, T &amp;v)</td></tr>
<tr class="separator:ga90274dfa0c2cf49e3b7cffb580fd85be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cb16202480a072671790dda4f217ac1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4cb16202480a072671790dda4f217ac1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IO.html#ga4cb16202480a072671790dda4f217ac1">operator&lt;</a> (std::ostream &amp;&amp;out, const T &amp;v)</td></tr>
<tr class="separator:ga4cb16202480a072671790dda4f217ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d970b2c306c1c170fffaf084b98467d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga0d970b2c306c1c170fffaf084b98467d">TAT_log</a> (const char *message)</td></tr>
<tr class="memdesc:ga0d970b2c306c1c170fffaf084b98467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TAT使用的日志打印  <a href="group__Miscellaneous.html#ga0d970b2c306c1c170fffaf084b98467d">更多...</a><br /></td></tr>
<tr class="separator:ga0d970b2c306c1c170fffaf084b98467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a782af59ad2716107ad7ca7615b1dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gae2a782af59ad2716107ad7ca7615b1dd">TAT_warning</a> (const char *message)</td></tr>
<tr class="memdesc:gae2a782af59ad2716107ad7ca7615b1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">TAT使用的打印警告  <a href="group__Miscellaneous.html#gae2a782af59ad2716107ad7ca7615b1dd">更多...</a><br /></td></tr>
<tr class="separator:gae2a782af59ad2716107ad7ca7615b1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f46f83982bd27a7e204d8a1360b6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga40f46f83982bd27a7e204d8a1360b6a0">TAT_error</a> (const char *message)</td></tr>
<tr class="memdesc:ga40f46f83982bd27a7e204d8a1360b6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">TAT使用的抛出运行时异常  <a href="group__Miscellaneous.html#ga40f46f83982bd27a7e204d8a1360b6a0">更多...</a><br /></td></tr>
<tr class="separator:ga40f46f83982bd27a7e204d8a1360b6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7047ea126e6800a5dacd06910817b383"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga7047ea126e6800a5dacd06910817b383"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga7047ea126e6800a5dacd06910817b383">operator+</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:ga7047ea126e6800a5dacd06910817b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd4828880a779ad810c1d8990aebc66"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga7dd4828880a779ad810c1d8990aebc66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga7dd4828880a779ad810c1d8990aebc66">operator+</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:ga7dd4828880a779ad810c1d8990aebc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99ec2d624e8a258c0805971759c7c20"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType1&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab99ec2d624e8a258c0805971759c7c20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gab99ec2d624e8a258c0805971759c7c20">operator+</a> (const ScalarType1 &amp;number_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:gab99ec2d624e8a258c0805971759c7c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22a1f0398536e2c864353309217b4c0"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:gae22a1f0398536e2c864353309217b4c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gae22a1f0398536e2c864353309217b4c0">operator-</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:gae22a1f0398536e2c864353309217b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefec6590aaea19299029cd8d328c20a"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:gacefec6590aaea19299029cd8d328c20a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gacefec6590aaea19299029cd8d328c20a">operator-</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:gacefec6590aaea19299029cd8d328c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223cdc779ae84723dbb1f8dda141f7c7"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType1&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga223cdc779ae84723dbb1f8dda141f7c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga223cdc779ae84723dbb1f8dda141f7c7">operator-</a> (const ScalarType1 &amp;number_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:ga223cdc779ae84723dbb1f8dda141f7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a2d9c124d2b4e9f143a57c6f1f5207"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:gaf3a2d9c124d2b4e9f143a57c6f1f5207"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gaf3a2d9c124d2b4e9f143a57c6f1f5207">operator*</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:gaf3a2d9c124d2b4e9f143a57c6f1f5207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558d05e485e6b20db81e4aae53ff40a0"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga558d05e485e6b20db81e4aae53ff40a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga558d05e485e6b20db81e4aae53ff40a0">operator*</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:ga558d05e485e6b20db81e4aae53ff40a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c240b61015114f3537bd895ecbf1508"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType1&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga9c240b61015114f3537bd895ecbf1508"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga9c240b61015114f3537bd895ecbf1508">operator*</a> (const ScalarType1 &amp;number_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:ga9c240b61015114f3537bd895ecbf1508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbf9c047ab208f29dfaa5358b04edea3"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:gabbf9c047ab208f29dfaa5358b04edea3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gabbf9c047ab208f29dfaa5358b04edea3">operator/</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:gabbf9c047ab208f29dfaa5358b04edea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad40061b79237f5c0e63be06a3be101bf"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:gad40061b79237f5c0e63be06a3be101bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gad40061b79237f5c0e63be06a3be101bf">operator/</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:gad40061b79237f5c0e63be06a3be101bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27618ca0abccaefce93b20933d77e71e"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType1&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga27618ca0abccaefce93b20933d77e71e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga27618ca0abccaefce93b20933d77e71e">operator/</a> (const ScalarType1 &amp;number_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:ga27618ca0abccaefce93b20933d77e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df74d72207e86e2a370fb50e81b0af9"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga1df74d72207e86e2a370fb50e81b0af9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga1df74d72207e86e2a370fb50e81b0af9">operator+=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:ga1df74d72207e86e2a370fb50e81b0af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab266de7fd539aaec21c24232f0f9bdab"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab266de7fd539aaec21c24232f0f9bdab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gab266de7fd539aaec21c24232f0f9bdab">operator+=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:gab266de7fd539aaec21c24232f0f9bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba39b9523324845e58a1bd4586f6d467"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:gaba39b9523324845e58a1bd4586f6d467"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gaba39b9523324845e58a1bd4586f6d467">operator+=</a> (<a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;singular, const ScalarType2 &amp;number)</td></tr>
<tr class="separator:gaba39b9523324845e58a1bd4586f6d467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f840da0df413c17f5109910a429266"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga05f840da0df413c17f5109910a429266"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga05f840da0df413c17f5109910a429266">operator-=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:ga05f840da0df413c17f5109910a429266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e9b75e2badc47ff3f0f87f5b7de229"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga98e9b75e2badc47ff3f0f87f5b7de229"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga98e9b75e2badc47ff3f0f87f5b7de229">operator-=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:ga98e9b75e2badc47ff3f0f87f5b7de229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f0afdf0ed30b52d726d7c3c6713fa8"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:gae9f0afdf0ed30b52d726d7c3c6713fa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gae9f0afdf0ed30b52d726d7c3c6713fa8">operator-=</a> (<a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;singular, const ScalarType2 &amp;number)</td></tr>
<tr class="separator:gae9f0afdf0ed30b52d726d7c3c6713fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d54e6abb04a6c0dd3f707adae783bc2"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:ga3d54e6abb04a6c0dd3f707adae783bc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga3d54e6abb04a6c0dd3f707adae783bc2">operator*=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:ga3d54e6abb04a6c0dd3f707adae783bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b40e918f5d5667b7a5d1a1666f8080c"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga5b40e918f5d5667b7a5d1a1666f8080c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga5b40e918f5d5667b7a5d1a1666f8080c">operator*=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:ga5b40e918f5d5667b7a5d1a1666f8080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1d3862fe9fde5b037d39d8d470a00e"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga4d1d3862fe9fde5b037d39d8d470a00e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga4d1d3862fe9fde5b037d39d8d470a00e">operator*=</a> (<a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;singular, const ScalarType2 &amp;number)</td></tr>
<tr class="separator:ga4d1d3862fe9fde5b037d39d8d470a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf16c231e8912b9e4a9cd78259a649cb"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name &gt; </td></tr>
<tr class="memitem:gadf16c231e8912b9e4a9cd78259a649cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#gadf16c231e8912b9e4a9cd78259a649cb">operator/=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2)</td></tr>
<tr class="separator:gadf16c231e8912b9e4a9cd78259a649cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9397081a05cabe257ede5ecec6480da9"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga9397081a05cabe257ede5ecec6480da9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga9397081a05cabe257ede5ecec6480da9">operator/=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const ScalarType2 &amp;number_2)</td></tr>
<tr class="separator:ga9397081a05cabe257ede5ecec6480da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3abc3f6c4fa13cffb1f78580b9bbfb"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 , typename Symmetry , typename Name , typename  = std::enable_if_t&lt;is_scalar_v&lt;ScalarType2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga8b3abc3f6c4fa13cffb1f78580b9bbfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Scalar.html#ga8b3abc3f6c4fa13cffb1f78580b9bbfb">operator/=</a> (<a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;singular, const ScalarType2 &amp;number)</td></tr>
<tr class="separator:ga8b3abc3f6c4fa13cffb1f78580b9bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf67904d5e53f7012dd6578754af92de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gabf67904d5e53f7012dd6578754af92de">TAT_nothing</a> (const char *)</td></tr>
<tr class="memdesc:gabf67904d5e53f7012dd6578754af92de"><td class="mdescLeft">&#160;</td><td class="mdescRight">什么事情也不做  <a href="group__Miscellaneous.html#gabf67904d5e53f7012dd6578754af92de">更多...</a><br /></td></tr>
<tr class="separator:gabf67904d5e53f7012dd6578754af92de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373d73fa9be8bc035464f2a9c03ff805"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timer.html#ga373d73fa9be8bc035464f2a9c03ff805">get_current_time</a> ()</td></tr>
<tr class="memdesc:ga373d73fa9be8bc035464f2a9c03ff805"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前时间点  <a href="group__Timer.html#ga373d73fa9be8bc035464f2a9c03ff805">更多...</a><br /></td></tr>
<tr class="separator:ga373d73fa9be8bc035464f2a9c03ff805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992b18d148636611b072413e3dbb9e14"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timer.html#ga992b18d148636611b072413e3dbb9e14">count_to_second</a> (const <a class="el" href="group__Timer.html#gaab1bb116bf0e7bc355dd91cae68bdf50">time_duration</a> &amp;count)</td></tr>
<tr class="memdesc:ga992b18d148636611b072413e3dbb9e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">将<code>std::chrono::high_resolution_clock::duration</code>转化为秒数  <a href="group__Timer.html#ga992b18d148636611b072413e3dbb9e14">更多...</a><br /></td></tr>
<tr class="separator:ga992b18d148636611b072413e3dbb9e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
变量</h2></td></tr>
<tr class="memitem:ga0d9bbe7f873167b6bfbd5d6a9569f8c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0d9bbe7f873167b6bfbd5d6a9569f8c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga0d9bbe7f873167b6bfbd5d6a9569f8c2">is_scalar_v</a> = <a class="el" href="structTAT_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ga0d9bbe7f873167b6bfbd5d6a9569f8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1b0248382d63decda4dd37d9c9b5ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaec1b0248382d63decda4dd37d9c9b5ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gaec1b0248382d63decda4dd37d9c9b5ad">is_complex_v</a> = <a class="el" href="structTAT_1_1is__complex.html">is_complex</a>&lt;T&gt;::value</td></tr>
<tr class="separator:gaec1b0248382d63decda4dd37d9c9b5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1bbfe4e4e42ae0982bb7ce4e4468ede"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac1bbfe4e4e42ae0982bb7ce4e4468ede"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gac1bbfe4e4e42ae0982bb7ce4e4468ede">is_real_v</a> = <a class="el" href="structTAT_1_1is__real.html">is_real</a>&lt;T&gt;::value</td></tr>
<tr class="separator:gac1bbfe4e4e42ae0982bb7ce4e4468ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47b781347f154f838f10f9d75adc63f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gac47b781347f154f838f10f9d75adc63f">use_simple_nosymmetry</a> = false</td></tr>
<tr class="separator:gac47b781347f154f838f10f9d75adc63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02096e25c843dd9b664a4563e17752fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga02096e25c843dd9b664a4563e17752fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Edge.html#ga02096e25c843dd9b664a4563e17752fa">is_edge_v</a> = <a class="el" href="structTAT_1_1is__edge.html">is_edge</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ga02096e25c843dd9b664a4563e17752fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff0950988386a714f0f9e737f79aa8b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTAT_1_1UnixColorCode.html">UnixColorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1ff0950988386a714f0f9e737f79aa8b">console_red</a> = &quot;\x1B[31m&quot;</td></tr>
<tr class="separator:ga1ff0950988386a714f0f9e737f79aa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f7b66a780be2a3c25a97fb51ff9fc9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTAT_1_1UnixColorCode.html">UnixColorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga33f7b66a780be2a3c25a97fb51ff9fc9">console_green</a> = &quot;\x1B[32m&quot;</td></tr>
<tr class="separator:ga33f7b66a780be2a3c25a97fb51ff9fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abd9dd3c1973d84ec13109f1a219b89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTAT_1_1UnixColorCode.html">UnixColorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga4abd9dd3c1973d84ec13109f1a219b89">console_yellow</a> = &quot;\x1B[33m&quot;</td></tr>
<tr class="separator:ga4abd9dd3c1973d84ec13109f1a219b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812c17cc2001a142260ae10bb8c4c1e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTAT_1_1UnixColorCode.html">UnixColorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga812c17cc2001a142260ae10bb8c4c1e6">console_blue</a> = &quot;\x1B[34m&quot;</td></tr>
<tr class="separator:ga812c17cc2001a142260ae10bb8c4c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c688241972425df2d55d7c13e93ed7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTAT_1_1UnixColorCode.html">UnixColorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga38c688241972425df2d55d7c13e93ed7">console_origin</a> = &quot;\x1B[0m&quot;</td></tr>
<tr class="separator:ga38c688241972425df2d55d7c13e93ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c342125e36b5bac804be1dffdc3219"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MPI.html#ga67c342125e36b5bac804be1dffdc3219">mpi_enabled</a> = true</td></tr>
<tr class="separator:ga67c342125e36b5bac804be1dffdc3219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8023345bfaa3e140a1b117a7aa5244d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1mpi__t.html">mpi_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MPI.html#ga8023345bfaa3e140a1b117a7aa5244d9">mpi</a></td></tr>
<tr class="separator:ga8023345bfaa3e140a1b117a7aa5244d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0580ec2573a7a551403bb6d43f5993"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Name.html#ga5c0580ec2573a7a551403bb6d43f5993">fast_name_dataset</a> = <a class="el" href="structTAT_1_1fast__name__dataset__t.html">fast_name_dataset_t</a>()</td></tr>
<tr class="memdesc:ga5c0580ec2573a7a551403bb6d43f5993"><td class="mdescLeft">&#160;</td><td class="mdescRight">FastName使用的映射表包含数到字符串和字符串到数两个映射  <a href="group__Name.html#ga5c0580ec2573a7a551403bb6d43f5993">更多...</a><br /></td></tr>
<tr class="separator:ga5c0580ec2573a7a551403bb6d43f5993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ebee51d36dc7cad94d0f8dce6242b9a"><td class="memTemplParams" colspan="2">template&lt;typename Name &gt; </td></tr>
<tr class="memitem:ga8ebee51d36dc7cad94d0f8dce6242b9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Name.html#ga8ebee51d36dc7cad94d0f8dce6242b9a">is_name_v</a> = <a class="el" href="structTAT_1_1is__name.html">is_name</a>&lt;Name&gt;::value</td></tr>
<tr class="separator:ga8ebee51d36dc7cad94d0f8dce6242b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e4fa70b8c586c3f434630a658e1378"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga77e4fa70b8c586c3f434630a658e1378"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Symmetry.html#ga77e4fa70b8c586c3f434630a658e1378">is_symmetry_v</a> = <a class="el" href="structTAT_1_1is__symmetry.html">is_symmetry</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ga77e4fa70b8c586c3f434630a658e1378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf811c19d1ad9b6a08e9e616a61b62038"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf811c19d1ad9b6a08e9e616a61b62038"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Symmetry.html#gaf811c19d1ad9b6a08e9e616a61b62038">is_bose_symmetry_v</a> = <a class="el" href="structTAT_1_1is__bose__symmetry.html">is_bose_symmetry</a>&lt;T&gt;::value</td></tr>
<tr class="separator:gaf811c19d1ad9b6a08e9e616a61b62038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34e28a8b930984824c1825b840078e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa34e28a8b930984824c1825b840078e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Symmetry.html#gaa34e28a8b930984824c1825b840078e7">is_fermi_symmetry_v</a> = <a class="el" href="structTAT_1_1is__fermi__symmetry.html">is_fermi_symmetry</a>&lt;T&gt;::value</td></tr>
<tr class="separator:gaa34e28a8b930984824c1825b840078e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4989bfe390f6c51321f9353b638e23"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga8c4989bfe390f6c51321f9353b638e23">version</a></td></tr>
<tr class="memdesc:ga8c4989bfe390f6c51321f9353b638e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">TAT的版本号  <a href="group__Miscellaneous.html#ga8c4989bfe390f6c51321f9353b638e23">更多...</a><br /></td></tr>
<tr class="separator:ga8c4989bfe390f6c51321f9353b638e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd3f61e9cfc98419950be0791e15e1d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga4bd3f61e9cfc98419950be0791e15e1d">information</a></td></tr>
<tr class="memdesc:ga4bd3f61e9cfc98419950be0791e15e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">编译与license的相关信息  <a href="group__Miscellaneous.html#ga4bd3f61e9cfc98419950be0791e15e1d">更多...</a><br /></td></tr>
<tr class="separator:ga4bd3f61e9cfc98419950be0791e15e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff69334b3964287a5bdbb9b990ec764"><td class="memItemLeft" align="right" valign="top">const evil_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#ga6ff69334b3964287a5bdbb9b990ec764">evil</a></td></tr>
<tr class="memdesc:ga6ff69334b3964287a5bdbb9b990ec764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug模式中, 将在程序末尾打印一行友情提示, 过早的优化是万恶之源, 同时此对象也控制windows下终端的色彩模式  <a href="group__Miscellaneous.html#ga6ff69334b3964287a5bdbb9b990ec764">更多...</a><br /></td></tr>
<tr class="separator:ga6ff69334b3964287a5bdbb9b990ec764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced2fb49de6baa28d8e73b53c04886bb"><td class="memItemLeft" align="right" valign="top">constexpr unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gaced2fb49de6baa28d8e73b53c04886bb">l1_cache</a></td></tr>
<tr class="memdesc:gaced2fb49de6baa28d8e73b53c04886bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">供转置中使用的l1 cache大小, 可由宏<code>TAT_L1_CACHE</code>设置  <a href="group__Miscellaneous.html#gaced2fb49de6baa28d8e73b53c04886bb">更多...</a><br /></td></tr>
<tr class="separator:gaced2fb49de6baa28d8e73b53c04886bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae3d68038af17639eefd556b248f176"><td class="memItemLeft" align="right" valign="top">constexpr unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gacae3d68038af17639eefd556b248f176">l2_cache</a></td></tr>
<tr class="memdesc:gacae3d68038af17639eefd556b248f176"><td class="mdescLeft">&#160;</td><td class="mdescRight">供转置中使用的l2 cache大小, 可由宏<code>TAT_L2_CACHE</code>设置  <a href="group__Miscellaneous.html#gacae3d68038af17639eefd556b248f176">更多...</a><br /></td></tr>
<tr class="separator:gacae3d68038af17639eefd556b248f176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7067efa2b043ff7b7031b1e14b1beb"><td class="memItemLeft" align="right" valign="top">constexpr unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Miscellaneous.html#gacc7067efa2b043ff7b7031b1e14b1beb">l3_cache</a></td></tr>
<tr class="memdesc:gacc7067efa2b043ff7b7031b1e14b1beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">供转置中使用的l3 cache大小, 可由宏<code>TAT_L3_CACHE</code>设置  <a href="group__Miscellaneous.html#gacc7067efa2b043ff7b7031b1e14b1beb">更多...</a><br /></td></tr>
<tr class="separator:gacc7067efa2b043ff7b7031b1e14b1beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66be153e48033d422f2d5946d42baa8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timer.html#gad66be153e48033d422f2d5946d42baa8">timer_stack</a> = timer_stack_t()</td></tr>
<tr class="memdesc:gad66be153e48033d422f2d5946d42baa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">统计各个函数时间用的栈  <a href="group__Timer.html#gad66be153e48033d422f2d5946d42baa8">更多...</a><br /></td></tr>
<tr class="separator:gad66be153e48033d422f2d5946d42baa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p><a class="el" href="namespaceTAT.html" title="TAT is A Tensor library">TAT</a> is A <a class="el" href="structTAT_1_1Tensor.html" title="张量类型">Tensor</a> library </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceTAT.html">TAT</a></li>
    <li class="footer">生成于 2020年 十二月 9日 星期三 01:49:45 , 为 TAT使用 
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
