<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TAT: TAT::Tensor&lt; ScalarType, Symmetry, Name &gt; 模板结构体 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TAT
   &#160;<span id="projectnumber">v0.1.0-rc.11</span>
   </div>
   <div id="projectbrief">TAT is A Tensor library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structTAT_1_1Tensor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pub-attribs">Public 属性</a> &#124;
<a href="#pub-static-attribs">静态 Public 属性</a> &#124;
<a href="structTAT_1_1Tensor-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">TAT::Tensor&lt; ScalarType, Symmetry, Name &gt; 模板结构体 参考<div class="ingroups"><a class="el" href="group__Tensor.html">Tensor</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>张量类型  
 <a href="structTAT_1_1Tensor.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="tensor_8hpp_source.html">tensor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor_1_1qr__result.html">qr_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量qr的结果类型  <a href="structTAT_1_1Tensor_1_1qr__result.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor_1_1svd__result.html">svd_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量svd的结果类型  <a href="structTAT_1_1Tensor_1_1svd__result.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a9cc15c9afe143966029c1d0dc8fa6f91"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a9cc15c9afe143966029c1d0dc8fa6f91">scalar_valid</a> = std::enable_if_t&lt; <a class="el" href="group__Miscellaneous.html#ga0d9bbe7f873167b6bfbd5d6a9569f8c2">is_scalar_v</a>&lt; ScalarType &gt; &gt;</td></tr>
<tr class="separator:a9cc15c9afe143966029c1d0dc8fa6f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b37643797ad7da56f258c2996a4135"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a04b37643797ad7da56f258c2996a4135">symmetry_valid</a> = std::enable_if_t&lt; <a class="el" href="group__Symmetry.html#ga77e4fa70b8c586c3f434630a658e1378">is_symmetry_v</a>&lt; Symmetry &gt; &gt;</td></tr>
<tr class="separator:a04b37643797ad7da56f258c2996a4135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529084aace9257dd27b0b61bde589888"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a529084aace9257dd27b0b61bde589888">name_valid</a> = std::enable_if_t&lt; <a class="el" href="group__Name.html#ga8ebee51d36dc7cad94d0f8dce6242b9a">is_name_v</a>&lt; Name &gt; &gt;</td></tr>
<tr class="separator:a529084aace9257dd27b0b61bde589888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf08baeb2eed70e2f64e7af12dfeb8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> = std::conditional_t&lt; std::is_same_v&lt; Symmetry, <a class="el" href="structTAT_1_1NoSymmetry.html">NoSymmetry</a> &gt;, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, std::tuple&lt; Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> &gt; &gt;</td></tr>
<tr class="separator:afaf08baeb2eed70e2f64e7af12dfeb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac499e258364f1d6fe53b081cf837648b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ac499e258364f1d6fe53b081cf837648b">EdgeInfoWithArrowForExpand</a> = std::conditional_t&lt; std::is_same_v&lt; Symmetry, <a class="el" href="structTAT_1_1NoSymmetry.html">NoSymmetry</a> &gt;, std::tuple&lt; <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> &gt;, std::conditional_t&lt; <a class="el" href="group__Symmetry.html#gaa34e28a8b930984824c1825b840078e7">is_fermi_symmetry_v</a>&lt; Symmetry &gt;, std::tuple&lt; <a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a>, Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> &gt;, std::tuple&lt; Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:ac499e258364f1d6fe53b081cf837648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb633a8b129a8c1f2b2b0caf5659815"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a1eb633a8b129a8c1f2b2b0caf5659815">MapIteratorList</a> = std::vector&lt; typename <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry &gt;::edge_map::const_iterator &gt;</td></tr>
<tr class="separator:a1eb633a8b129a8c1f2b2b0caf5659815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae719096b85159cda723101729ee703"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a8ae719096b85159cda723101729ee703">SingularType</a> = <a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt; ScalarType, Symmetry, Name &gt;</td></tr>
<tr class="separator:a8ae719096b85159cda723101729ee703"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a249f71a6068ebf0932c6566e18c3e11b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a249f71a6068ebf0932c6566e18c3e11b">Tensor</a> (std::vector&lt; Name &gt; names_init, std::vector&lt; <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry &gt;&gt; edges_init, const bool auto_reverse=false)</td></tr>
<tr class="memdesc:a249f71a6068ebf0932c6566e18c3e11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据张量边的名称和形状构造张量, 分块将自动根据对称性进行处理  <a href="structTAT_1_1Tensor.html#a249f71a6068ebf0932c6566e18c3e11b">更多...</a><br /></td></tr>
<tr class="separator:a249f71a6068ebf0932c6566e18c3e11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a99ba8f4a7a6a7e1185b6fac04cbb58"><td class="memTemplParams" colspan="2">template&lt;typename Int  = Size, typename  = std::enable_if_t&lt;std::is_same_v&lt;Symmetry, NoSymmetry&gt; &amp;&amp; !std::is_same_v&lt;Int, Edge&lt;Symmetry&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a7a99ba8f4a7a6a7e1185b6fac04cbb58"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a7a99ba8f4a7a6a7e1185b6fac04cbb58">Tensor</a> (std::vector&lt; Name &gt; names_init, const std::vector&lt; Int &gt; &amp;edges_init)</td></tr>
<tr class="separator:a7a99ba8f4a7a6a7e1185b6fac04cbb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d94cc5a258afdf3b256779df8a8bd9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a9d94cc5a258afdf3b256779df8a8bd9b">copy</a> () const</td></tr>
<tr class="memdesc:a9d94cc5a258afdf3b256779df8a8bd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量的复制, 默认的赋值和复制初始化不会拷贝数据，而会共用core  <a href="structTAT_1_1Tensor.html#a9d94cc5a258afdf3b256779df8a8bd9b">更多...</a><br /></td></tr>
<tr class="separator:a9d94cc5a258afdf3b256779df8a8bd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67773ad17527d10e1129478340cda72e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a67773ad17527d10e1129478340cda72e">is_valid</a> () const</td></tr>
<tr class="separator:a67773ad17527d10e1129478340cda72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7be591e974161d7c1b5a94082abb937"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ad7be591e974161d7c1b5a94082abb937">Tensor</a> ()=default</td></tr>
<tr class="separator:ad7be591e974161d7c1b5a94082abb937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cbc74cf19e0679da158385dc3eaa0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a44cbc74cf19e0679da158385dc3eaa0e">Tensor</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a> &amp;other)=default</td></tr>
<tr class="separator:a44cbc74cf19e0679da158385dc3eaa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eb853d59666d3086dfe4044521d8e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ad0eb853d59666d3086dfe4044521d8e8">Tensor</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="separator:ad0eb853d59666d3086dfe4044521d8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1ca6a58056b952a50e3238ba2a533c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a2e1ca6a58056b952a50e3238ba2a533c">operator=</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a> &amp;other)=default</td></tr>
<tr class="separator:a2e1ca6a58056b952a50e3238ba2a533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6470e216cc48981c2ebf754e3a83f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a0f6470e216cc48981c2ebf754e3a83f9">operator=</a> (<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="separator:a0f6470e216cc48981c2ebf754e3a83f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d423525b08fa4b1624435798c2be80d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a1d423525b08fa4b1624435798c2be80d">~Tensor</a> ()=default</td></tr>
<tr class="separator:a1d423525b08fa4b1624435798c2be80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4804ab139acbaa19d5efb0b033653e71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a4804ab139acbaa19d5efb0b033653e71">Tensor</a> (ScalarType number)</td></tr>
<tr class="memdesc:a4804ab139acbaa19d5efb0b033653e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建秩为零的张量  <a href="structTAT_1_1Tensor.html#a4804ab139acbaa19d5efb0b033653e71">更多...</a><br /></td></tr>
<tr class="separator:a4804ab139acbaa19d5efb0b033653e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a45b860499d4eaa7829efd3bcbdb1e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a2a45b860499d4eaa7829efd3bcbdb1e9">is_scalar</a> () const</td></tr>
<tr class="separator:a2a45b860499d4eaa7829efd3bcbdb1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab836bd75946c187a1cc2acbaf1921cb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ab836bd75946c187a1cc2acbaf1921cb6">operator ScalarType</a> () const</td></tr>
<tr class="memdesc:ab836bd75946c187a1cc2acbaf1921cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">秩为一的张量转化为其中唯一一个元素的标量类型  <a href="structTAT_1_1Tensor.html#ab836bd75946c187a1cc2acbaf1921cb6">更多...</a><br /></td></tr>
<tr class="separator:ab836bd75946c187a1cc2acbaf1921cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad907b1894ad6b0e54b92e3c2f28574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#acad907b1894ad6b0e54b92e3c2f28574">expand</a> (const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#ac499e258364f1d6fe53b081cf837648b">EdgeInfoWithArrowForExpand</a> &gt; &amp;configure, const Name &amp;old_name=<a class="el" href="structTAT_1_1InternalName.html">InternalName</a>&lt; Name &gt;::No_Old_Name) const</td></tr>
<tr class="separator:acad907b1894ad6b0e54b92e3c2f28574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e84e32ab8019597c60ada6f9a45ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a626e84e32ab8019597c60ada6f9a45ea">shrink</a> (const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;configure, const Name &amp;new_name=<a class="el" href="structTAT_1_1InternalName.html">InternalName</a>&lt; Name &gt;::No_New_Name, <a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a> arrow=false) const</td></tr>
<tr class="separator:a626e84e32ab8019597c60ada6f9a45ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1791bdc2285cf186be58d30d7c9f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ace1791bdc2285cf186be58d30d7c9f42">slice</a> (const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;configure, const Name &amp;new_name=<a class="el" href="structTAT_1_1InternalName.html">InternalName</a>&lt; Name &gt;::No_New_Name, <a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a> arrow=false) const</td></tr>
<tr class="separator:ace1791bdc2285cf186be58d30d7c9f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8419fd382c3d74ceafb7b9b06e0214ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a8419fd382c3d74ceafb7b9b06e0214ca">same_shape</a> () const</td></tr>
<tr class="memdesc:a8419fd382c3d74ceafb7b9b06e0214ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">产生一个与自己形状一样的张量  <a href="structTAT_1_1Tensor.html#a8419fd382c3d74ceafb7b9b06e0214ca">更多...</a><br /></td></tr>
<tr class="separator:a8419fd382c3d74ceafb7b9b06e0214ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b84a6f099ca0193a0ad6e9e8e04415"><td class="memTemplParams" colspan="2">template&lt;typename Transform &gt; </td></tr>
<tr class="memitem:aa6b84a6f099ca0193a0ad6e9e8e04415"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#aa6b84a6f099ca0193a0ad6e9e8e04415">map</a> (Transform &amp;&amp;function) const</td></tr>
<tr class="memdesc:aa6b84a6f099ca0193a0ad6e9e8e04415"><td class="mdescLeft">&#160;</td><td class="mdescRight">对张量的每个数据元素做同样的非原地的变换  <a href="structTAT_1_1Tensor.html#aa6b84a6f099ca0193a0ad6e9e8e04415">更多...</a><br /></td></tr>
<tr class="separator:aa6b84a6f099ca0193a0ad6e9e8e04415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0ec0802ec95a255a99bc42d94dd1f"><td class="memTemplParams" colspan="2">template&lt;typename Transform &gt; </td></tr>
<tr class="memitem:acba0ec0802ec95a255a99bc42d94dd1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#acba0ec0802ec95a255a99bc42d94dd1f">transform</a> (Transform &amp;&amp;function) &amp;</td></tr>
<tr class="memdesc:acba0ec0802ec95a255a99bc42d94dd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">对张量的每个数据元素做同样的原地的变换  <a href="structTAT_1_1Tensor.html#acba0ec0802ec95a255a99bc42d94dd1f">更多...</a><br /></td></tr>
<tr class="separator:acba0ec0802ec95a255a99bc42d94dd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf93a852d354ee03e3ae33e278ec396"><td class="memTemplParams" colspan="2">template&lt;typename Transform &gt; </td></tr>
<tr class="memitem:a9cf93a852d354ee03e3ae33e278ec396"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a9cf93a852d354ee03e3ae33e278ec396">transform</a> (Transform &amp;&amp;function) &amp;&amp;</td></tr>
<tr class="separator:a9cf93a852d354ee03e3ae33e278ec396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fa382fd250903d72418b8e10ed4a65"><td class="memTemplParams" colspan="2">template&lt;typename Generator &gt; </td></tr>
<tr class="memitem:ac7fa382fd250903d72418b8e10ed4a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ac7fa382fd250903d72418b8e10ed4a65">set</a> (Generator &amp;&amp;generator) &amp;</td></tr>
<tr class="memdesc:ac7fa382fd250903d72418b8e10ed4a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">通过一个生成器设置一个张量内的数据  <a href="structTAT_1_1Tensor.html#ac7fa382fd250903d72418b8e10ed4a65">更多...</a><br /></td></tr>
<tr class="separator:ac7fa382fd250903d72418b8e10ed4a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c908557416bb3b3c72896320aa30106"><td class="memTemplParams" colspan="2">template&lt;typename Generator &gt; </td></tr>
<tr class="memitem:a2c908557416bb3b3c72896320aa30106"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a2c908557416bb3b3c72896320aa30106">set</a> (Generator &amp;&amp;generator) &amp;&amp;</td></tr>
<tr class="separator:a2c908557416bb3b3c72896320aa30106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25052984c028c2913d77fc0ed079f02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a25052984c028c2913d77fc0ed079f02d">zero</a> () &amp;</td></tr>
<tr class="memdesc:a25052984c028c2913d77fc0ed079f02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">将张量内的数据全部设置为零  <a href="structTAT_1_1Tensor.html#a25052984c028c2913d77fc0ed079f02d">更多...</a><br /></td></tr>
<tr class="separator:a25052984c028c2913d77fc0ed079f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63a2323a01a71dda38b8856cb5a532b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ae63a2323a01a71dda38b8856cb5a532b">zero</a> () &amp;&amp;</td></tr>
<tr class="separator:ae63a2323a01a71dda38b8856cb5a532b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070c446e688bad4dd586b4e5f23ebb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a070c446e688bad4dd586b4e5f23ebb6c">test</a> (ScalarType first=0, ScalarType step=1) &amp;</td></tr>
<tr class="memdesc:a070c446e688bad4dd586b4e5f23ebb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">将张量内的数据设置为便于测试的值  <a href="structTAT_1_1Tensor.html#a070c446e688bad4dd586b4e5f23ebb6c">更多...</a><br /></td></tr>
<tr class="separator:a070c446e688bad4dd586b4e5f23ebb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4f7437b71de7367ca2623a2111aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a0fe4f7437b71de7367ca2623a2111aaa">test</a> (ScalarType first=0, ScalarType step=1) &amp;&amp;</td></tr>
<tr class="separator:a0fe4f7437b71de7367ca2623a2111aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d8eca0c4f84479cce88768038592d9"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ab8d8eca0c4f84479cce88768038592d9">block</a> (const std::map&lt; Name, Symmetry &gt; &amp;position={}) const &amp;</td></tr>
<tr class="memdesc:ab8d8eca0c4f84479cce88768038592d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取张量的某个分块  <a href="structTAT_1_1Tensor.html#ab8d8eca0c4f84479cce88768038592d9">更多...</a><br /></td></tr>
<tr class="separator:ab8d8eca0c4f84479cce88768038592d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c795d887c0c0a8df0839395f391ab6"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a83c795d887c0c0a8df0839395f391ab6">block</a> (const std::map&lt; Name, Symmetry &gt; &amp;position={}) &amp;</td></tr>
<tr class="separator:a83c795d887c0c0a8df0839395f391ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d53d8dd85af8c4a0ee21fbc8dd6b41"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a24d53d8dd85af8c4a0ee21fbc8dd6b41">const_block</a> (const std::map&lt; Name, Symmetry &gt; &amp;position={}) const &amp;</td></tr>
<tr class="separator:a24d53d8dd85af8c4a0ee21fbc8dd6b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af47d0d4040ad64017c416f449a67cf"><td class="memItemLeft" align="right" valign="top">const ScalarType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a5af47d0d4040ad64017c416f449a67cf">at</a> (const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;position) const &amp;</td></tr>
<tr class="memdesc:a5af47d0d4040ad64017c416f449a67cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取张量中某个分块内的某个元素  <a href="structTAT_1_1Tensor.html#a5af47d0d4040ad64017c416f449a67cf">更多...</a><br /></td></tr>
<tr class="separator:a5af47d0d4040ad64017c416f449a67cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce420223565a0c04d296dfa865ae21a"><td class="memItemLeft" align="right" valign="top">ScalarType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a4ce420223565a0c04d296dfa865ae21a">at</a> (const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;position) &amp;</td></tr>
<tr class="separator:a4ce420223565a0c04d296dfa865ae21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cebe372f267460b8d0a558e2db7139a"><td class="memItemLeft" align="right" valign="top">const ScalarType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a4cebe372f267460b8d0a558e2db7139a">const_at</a> (const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;position) const &amp;</td></tr>
<tr class="separator:a4cebe372f267460b8d0a558e2db7139a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab102bd3898b58fff24b10ed07f3221e6"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalarType , typename  = std::enable_if_t&lt;is_scalar_v&lt;OtherScalarType&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab102bd3898b58fff24b10ed07f3221e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; OtherScalarType, Symmetry, Name &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ab102bd3898b58fff24b10ed07f3221e6">to</a> () const</td></tr>
<tr class="memdesc:ab102bd3898b58fff24b10ed07f3221e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">不同标量类型的张量之间的转换函数  <a href="structTAT_1_1Tensor.html#ab102bd3898b58fff24b10ed07f3221e6">更多...</a><br /></td></tr>
<tr class="separator:ab102bd3898b58fff24b10ed07f3221e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb81dfbd5808d32766b0acf5a60a9aa"><td class="memTemplParams" colspan="2">template&lt;int p = 2&gt; </td></tr>
<tr class="memitem:a6cb81dfbd5808d32766b0acf5a60a9aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__Miscellaneous.html#ga03fb813e3f2c8c1633ebe103894051a3">real_base_t</a>&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a6cb81dfbd5808d32766b0acf5a60a9aa">norm</a> () const</td></tr>
<tr class="memdesc:a6cb81dfbd5808d32766b0acf5a60a9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">求张量的模, 是拉平看作向量的模, 并不是矩阵模之类的东西  <a href="structTAT_1_1Tensor.html#a6cb81dfbd5808d32766b0acf5a60a9aa">更多...</a><br /></td></tr>
<tr class="separator:a6cb81dfbd5808d32766b0acf5a60a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df7b1315f2abd7065ef9f2053ee9a7a"><td class="memTemplParams" colspan="2">template&lt;bool split_edge_is_pointer = false&gt; </td></tr>
<tr class="memitem:a4df7b1315f2abd7065ef9f2053ee9a7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a4df7b1315f2abd7065ef9f2053ee9a7a">edge_operator</a> (const std::map&lt; Name, Name &gt; &amp;rename_map, const std::map&lt; Name, std::vector&lt; std::tuple&lt; Name, <a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a>&lt; Symmetry, split_edge_is_pointer &gt;&gt;&gt;&gt; &amp;split_map, const std::set&lt; Name &gt; &amp;reversed_name, const std::map&lt; Name, std::vector&lt; Name &gt;&gt; &amp;merge_map, std::vector&lt; Name &gt; new_names, bool apply_parity=false, const std::array&lt; std::set&lt; Name &gt;, 4 &gt; &amp;parity_exclude_name={{{}, {}, {}, {}}}, const std::map&lt; Name, std::map&lt; Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> &gt;&gt; &amp;edge_and_symmetries_to_cut_before_all={}) const</td></tr>
<tr class="memdesc:a4df7b1315f2abd7065ef9f2053ee9a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">对张量的边进行操作的中枢函数, 对边依次做重命名, 分裂, 费米箭头取反, 合并, 转置的操作,  <a href="structTAT_1_1Tensor.html#a4df7b1315f2abd7065ef9f2053ee9a7a">更多...</a><br /></td></tr>
<tr class="separator:a4df7b1315f2abd7065ef9f2053ee9a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f4ac89efc12b4afdfbe6fb12cb781b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ad8f4ac89efc12b4afdfbe6fb12cb781b">edge_rename</a> (const std::map&lt; Name, Name &gt; &amp;dictionary) const</td></tr>
<tr class="memdesc:ad8f4ac89efc12b4afdfbe6fb12cb781b"><td class="mdescLeft">&#160;</td><td class="mdescRight">对张量边的名称进行重命名  <a href="structTAT_1_1Tensor.html#ad8f4ac89efc12b4afdfbe6fb12cb781b">更多...</a><br /></td></tr>
<tr class="separator:ad8f4ac89efc12b4afdfbe6fb12cb781b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439e664b9580d6514c65f7f866f288d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a439e664b9580d6514c65f7f866f288d2">transpose</a> (std::vector&lt; Name &gt; target_names) const</td></tr>
<tr class="memdesc:a439e664b9580d6514c65f7f866f288d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">对张量进行转置  <a href="structTAT_1_1Tensor.html#a439e664b9580d6514c65f7f866f288d2">更多...</a><br /></td></tr>
<tr class="separator:a439e664b9580d6514c65f7f866f288d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe401ff6d00b18a4e110e4e6b8aa3aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#abbe401ff6d00b18a4e110e4e6b8aa3aa">reverse_edge</a> (const std::set&lt; Name &gt; &amp;reversed_name, bool apply_parity=false, const std::set&lt; Name &gt; &amp;parity_exclude_name={}) const</td></tr>
<tr class="memdesc:abbe401ff6d00b18a4e110e4e6b8aa3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">将费米张量的一些边进行反转  <a href="structTAT_1_1Tensor.html#abbe401ff6d00b18a4e110e4e6b8aa3aa">更多...</a><br /></td></tr>
<tr class="separator:abbe401ff6d00b18a4e110e4e6b8aa3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c9939fc28077a7aaabc7da37aeab66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ae7c9939fc28077a7aaabc7da37aeab66">merge_edge</a> (std::map&lt; Name, std::vector&lt; Name &gt;&gt; merge, bool apply_parity=false, const std::set&lt; Name &gt; &amp;parity_exclude_name_merge={}, const std::set&lt; Name &gt; &amp;parity_exclude_name_reverse={}) const</td></tr>
<tr class="memdesc:ae7c9939fc28077a7aaabc7da37aeab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">合并张量的一些边  <a href="structTAT_1_1Tensor.html#ae7c9939fc28077a7aaabc7da37aeab66">更多...</a><br /></td></tr>
<tr class="separator:ae7c9939fc28077a7aaabc7da37aeab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c9d5865a9866a31a44db38b6aaf5b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ab2c9d5865a9866a31a44db38b6aaf5b8">split_edge</a> (std::map&lt; Name, std::vector&lt; std::tuple&lt; Name, <a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a>&lt; Symmetry &gt;&gt;&gt;&gt; split, bool apply_parity=false, const std::set&lt; Name &gt; &amp;parity_exclude_name_split={}) const</td></tr>
<tr class="memdesc:ab2c9d5865a9866a31a44db38b6aaf5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">分裂张量的一些边  <a href="structTAT_1_1Tensor.html#ab2c9d5865a9866a31a44db38b6aaf5b8">更多...</a><br /></td></tr>
<tr class="separator:ab2c9d5865a9866a31a44db38b6aaf5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246a14a49fc37102d2b184d4cc08c11b"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalarType &gt; </td></tr>
<tr class="memitem:a246a14a49fc37102d2b184d4cc08c11b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a246a14a49fc37102d2b184d4cc08c11b">contract</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; OtherScalarType, Symmetry, Name &gt; &amp;tensor_2, std::set&lt; std::tuple&lt; Name, Name &gt;&gt; contract_names) const</td></tr>
<tr class="separator:a246a14a49fc37102d2b184d4cc08c11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99633cbb2776da691ad804a23f8e7d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a99633cbb2776da691ad804a23f8e7d99">contract_all_edge</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;other) const</td></tr>
<tr class="memdesc:a99633cbb2776da691ad804a23f8e7d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">将一个张量与另一个张量的所有相同名称的边进行缩并  <a href="structTAT_1_1Tensor.html#a99633cbb2776da691ad804a23f8e7d99">更多...</a><br /></td></tr>
<tr class="separator:a99633cbb2776da691ad804a23f8e7d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d58b022a6f1eaa0dfb74dcb145eb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ac9d58b022a6f1eaa0dfb74dcb145eb31">contract_all_edge</a> () const</td></tr>
<tr class="memdesc:ac9d58b022a6f1eaa0dfb74dcb145eb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量与自己的共轭进行尽可能的缩并  <a href="structTAT_1_1Tensor.html#ac9d58b022a6f1eaa0dfb74dcb145eb31">更多...</a><br /></td></tr>
<tr class="separator:ac9d58b022a6f1eaa0dfb74dcb145eb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5065992828c0a3cb6b8358ea0adbd4fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a5065992828c0a3cb6b8358ea0adbd4fc">identity</a> (const std::set&lt; std::tuple&lt; Name, Name &gt;&gt; &amp;pairs) const</td></tr>
<tr class="memdesc:a5065992828c0a3cb6b8358ea0adbd4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">生成相同形状的单位张量  <a href="structTAT_1_1Tensor.html#a5065992828c0a3cb6b8358ea0adbd4fc">更多...</a><br /></td></tr>
<tr class="separator:a5065992828c0a3cb6b8358ea0adbd4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f426b740f06990a2decc2213413de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#af2f426b740f06990a2decc2213413de5">exponential</a> (const std::set&lt; std::tuple&lt; Name, Name &gt;&gt; &amp;pairs, int step=2) const</td></tr>
<tr class="memdesc:af2f426b740f06990a2decc2213413de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">看作矩阵后求出矩阵指数  <a href="structTAT_1_1Tensor.html#af2f426b740f06990a2decc2213413de5">更多...</a><br /></td></tr>
<tr class="separator:af2f426b740f06990a2decc2213413de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e8b48602667685790b72681050af1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ab1e8b48602667685790b72681050af1c">conjugate</a> () const</td></tr>
<tr class="memdesc:ab1e8b48602667685790b72681050af1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">生成张量的共轭张量  <a href="structTAT_1_1Tensor.html#ab1e8b48602667685790b72681050af1c">更多...</a><br /></td></tr>
<tr class="separator:ab1e8b48602667685790b72681050af1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a076f5dddae84960769976d67e136b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a0a076f5dddae84960769976d67e136b8">trace</a> (const std::set&lt; std::tuple&lt; Name, Name &gt;&gt; &amp;trace_names) const</td></tr>
<tr class="separator:a0a076f5dddae84960769976d67e136b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa827a3d73c6b1517abf7e5c1f472561f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#aa827a3d73c6b1517abf7e5c1f472561f">multiple</a> (const <a class="el" href="structTAT_1_1Tensor.html#a8ae719096b85159cda723101729ee703">SingularType</a> &amp;S, const Name &amp;name, char direction, bool division=false) const</td></tr>
<tr class="memdesc:aa827a3d73c6b1517abf7e5c1f472561f"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量缩并上SVD产生的奇异值数据, 就地操作  <a href="structTAT_1_1Tensor.html#aa827a3d73c6b1517abf7e5c1f472561f">更多...</a><br /></td></tr>
<tr class="separator:aa827a3d73c6b1517abf7e5c1f472561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d89e92d6d758c7bfac52e84f3265f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor_1_1svd__result.html">svd_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a9d89e92d6d758c7bfac52e84f3265f20">svd</a> (const std::set&lt; Name &gt; &amp;free_name_set_u, const Name &amp;common_name_u, const Name &amp;common_name_v, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> cut=<a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>(-1)) const</td></tr>
<tr class="memdesc:a9d89e92d6d758c7bfac52e84f3265f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">对张量进行svd分解  <a href="structTAT_1_1Tensor.html#a9d89e92d6d758c7bfac52e84f3265f20">更多...</a><br /></td></tr>
<tr class="separator:a9d89e92d6d758c7bfac52e84f3265f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342a8acb21bfa6dcd6c45a4b4efc3145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor_1_1qr__result.html">qr_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a342a8acb21bfa6dcd6c45a4b4efc3145">qr</a> (char free_name_direction, const std::set&lt; Name &gt; &amp;free_name_set, const Name &amp;common_name_q, const Name &amp;common_name_r) const</td></tr>
<tr class="memdesc:a342a8acb21bfa6dcd6c45a4b4efc3145"><td class="mdescLeft">&#160;</td><td class="mdescRight">对张量进行qr分解  <a href="structTAT_1_1Tensor.html#a342a8acb21bfa6dcd6c45a4b4efc3145">更多...</a><br /></td></tr>
<tr class="separator:a342a8acb21bfa6dcd6c45a4b4efc3145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab409a6f2d8f3ea1812b65a240ba5280c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ab409a6f2d8f3ea1812b65a240ba5280c">send</a> (int destination) const</td></tr>
<tr class="memdesc:ab409a6f2d8f3ea1812b65a240ba5280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">source调用此函数, 向destination发送一个张量  <a href="structTAT_1_1Tensor.html#ab409a6f2d8f3ea1812b65a240ba5280c">更多...</a><br /></td></tr>
<tr class="separator:ab409a6f2d8f3ea1812b65a240ba5280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cdde69a41a39bdd528983f775ce9a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ae4cdde69a41a39bdd528983f775ce9a1">send_receive</a> (int source, int destination) const</td></tr>
<tr class="memdesc:ae4cdde69a41a39bdd528983f775ce9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">像简单类型一样使用mpi但send和receive, 调用后, 一个destination返回source调用时输入tensor, 其他进程返回空张量  <a href="structTAT_1_1Tensor.html#ae4cdde69a41a39bdd528983f775ce9a1">更多...</a><br /></td></tr>
<tr class="separator:ae4cdde69a41a39bdd528983f775ce9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd35ca572f1bec93ba43b4a9de5e69d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a6cd35ca572f1bec93ba43b4a9de5e69d">broadcast</a> (int root) const</td></tr>
<tr class="memdesc:a6cd35ca572f1bec93ba43b4a9de5e69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">从root进程分发张量, 使用简单的树形分发, 必须所有进程一起调用这个函数  <a href="structTAT_1_1Tensor.html#a6cd35ca572f1bec93ba43b4a9de5e69d">更多...</a><br /></td></tr>
<tr class="separator:a6cd35ca572f1bec93ba43b4a9de5e69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2117eb5c897ed1ac6a42807966e372d"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ab2117eb5c897ed1ac6a42807966e372d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ab2117eb5c897ed1ac6a42807966e372d">reduce</a> (int root, Func &amp;&amp;function) const</td></tr>
<tr class="memdesc:ab2117eb5c897ed1ac6a42807966e372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">向root进程reduce张量, 使用简单的树形reduce, 必须所有进程一起调用这个函数, 最后root进程返回全部reduce的结果, 其他进程为中间结果一般无意义  <a href="structTAT_1_1Tensor.html#ab2117eb5c897ed1ac6a42807966e372d">更多...</a><br /></td></tr>
<tr class="separator:ab2117eb5c897ed1ac6a42807966e372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913bb31e5ca738fb74f646e5512a4c36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a913bb31e5ca738fb74f646e5512a4c36">summary</a> (const int root) const</td></tr>
<tr class="separator:a913bb31e5ca738fb74f646e5512a4c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ae6a33f427b718575a001beaa4c3b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga49ae6a33f427b718575a001beaa4c3b8">meta_put</a> (std::ostream &amp;) const</td></tr>
<tr class="separator:ga49ae6a33f427b718575a001beaa4c3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5484f651844dffccddb98f69248f69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8e5484f651844dffccddb98f69248f69">data_put</a> (std::ostream &amp;) const</td></tr>
<tr class="separator:ga8e5484f651844dffccddb98f69248f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064bded492880e88045141844fe30ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga064bded492880e88045141844fe30ec1">meta_get</a> (std::istream &amp;)</td></tr>
<tr class="separator:ga064bded492880e88045141844fe30ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga324fca0e2b2ab0e6e4524bda982788fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga324fca0e2b2ab0e6e4524bda982788fd">data_get</a> (std::istream &amp;)</td></tr>
<tr class="separator:ga324fca0e2b2ab0e6e4524bda982788fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f350c294d755e5988a4d1d815770bca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga5f350c294d755e5988a4d1d815770bca">show</a> () const</td></tr>
<tr class="separator:ga5f350c294d755e5988a4d1d815770bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ec761051073a9191f308e42042a515"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga59ec761051073a9191f308e42042a515">dump</a> () const</td></tr>
<tr class="separator:ga59ec761051073a9191f308e42042a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202ef1071a4e51b6344395ffbad6f1b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a202ef1071a4e51b6344395ffbad6f1b8">load</a> (const std::string &amp;) &amp;</td></tr>
<tr class="separator:a202ef1071a4e51b6344395ffbad6f1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccf842a212e8fb6b64cdf6585d2619e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#adccf842a212e8fb6b64cdf6585d2619e">load</a> (const std::string &amp;string) &amp;&amp;</td></tr>
<tr class="separator:adccf842a212e8fb6b64cdf6585d2619e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a24856542d03837f09da3a2f2efd78c67"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a24856542d03837f09da3a2f2efd78c67">one</a> (ScalarType number, std::vector&lt; Name &gt; names_init, const std::vector&lt; Symmetry &gt; &amp;edge_symmetry={}, const std::vector&lt; <a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a> &gt; &amp;edge_arrow={})</td></tr>
<tr class="memdesc:a24856542d03837f09da3a2f2efd78c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建高秩但是元素只有一个的张量  <a href="structTAT_1_1Tensor.html#a24856542d03837f09da3a2f2efd78c67">更多...</a><br /></td></tr>
<tr class="separator:a24856542d03837f09da3a2f2efd78c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0abaf67e239dc3e74a83aafdf31c3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ada0abaf67e239dc3e74a83aafdf31c3b">contract</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;tensor_2, std::set&lt; std::tuple&lt; Name, Name &gt;&gt; contract_names)</td></tr>
<tr class="memdesc:ada0abaf67e239dc3e74a83aafdf31c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">两个张量的缩并运算  <a href="structTAT_1_1Tensor.html#ada0abaf67e239dc3e74a83aafdf31c3b">更多...</a><br /></td></tr>
<tr class="separator:ada0abaf67e239dc3e74a83aafdf31c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3ee11efb23ff4d93e6a565d607cbfe"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr class="memitem:afe3ee11efb23ff4d93e6a565d607cbfe"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#afe3ee11efb23ff4d93e6a565d607cbfe">contract</a> (const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;tensor_1, const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;tensor_2, std::set&lt; std::tuple&lt; Name, Name &gt;&gt; contract_names)</td></tr>
<tr class="separator:afe3ee11efb23ff4d93e6a565d607cbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad208b0c8577ff1d5fed6a2b2c945698e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ad208b0c8577ff1d5fed6a2b2c945698e">receive</a> (int source)</td></tr>
<tr class="memdesc:ad208b0c8577ff1d5fed6a2b2c945698e"><td class="mdescLeft">&#160;</td><td class="mdescRight">destination调用此函数, 从source接受一个张量  <a href="structTAT_1_1Tensor.html#ad208b0c8577ff1d5fed6a2b2c945698e">更多...</a><br /></td></tr>
<tr class="separator:ad208b0c8577ff1d5fed6a2b2c945698e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5d2765c5e944925af511d75c5a7690"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#a9b5d2765c5e944925af511d75c5a7690">barrier</a> ()</td></tr>
<tr class="memdesc:a9b5d2765c5e944925af511d75c5a7690"><td class="mdescLeft">&#160;</td><td class="mdescRight">mpi进程间同步  <a href="structTAT_1_1Tensor.html#a9b5d2765c5e944925af511d75c5a7690">更多...</a><br /></td></tr>
<tr class="separator:a9b5d2765c5e944925af511d75c5a7690"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public 属性</h2></td></tr>
<tr class="memitem:aff3fe646de6b8d94251e0d8096cad12b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Name &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#aff3fe646de6b8d94251e0d8096cad12b">names</a></td></tr>
<tr class="memdesc:aff3fe646de6b8d94251e0d8096cad12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量的边的名称  <a href="structTAT_1_1Tensor.html#aff3fe646de6b8d94251e0d8096cad12b">更多...</a><br /></td></tr>
<tr class="separator:aff3fe646de6b8d94251e0d8096cad12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dca3481df8511db539e12297b8dc90"><td class="memItemLeft" align="right" valign="top">std::map&lt; Name, <a class="el" href="group__Miscellaneous.html#ga62eb09d4bc76da9469d3a43882ca295a">Rank</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ad4dca3481df8511db539e12297b8dc90">name_to_index</a></td></tr>
<tr class="memdesc:ad4dca3481df8511db539e12297b8dc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量边名称到边的序号的映射表  <a href="structTAT_1_1Tensor.html#ad4dca3481df8511db539e12297b8dc90">更多...</a><br /></td></tr>
<tr class="separator:ad4dca3481df8511db539e12297b8dc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd1a1522ea372390783d72cc23fedf2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structTAT_1_1Core.html">Core</a>&lt; ScalarType, Symmetry &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#aadd1a1522ea372390783d72cc23fedf2">core</a></td></tr>
<tr class="memdesc:aadd1a1522ea372390783d72cc23fedf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">张量中出了边名称外的其他数据  <a href="structTAT_1_1Tensor.html#aadd1a1522ea372390783d72cc23fedf2">更多...</a><br /></td></tr>
<tr class="separator:aadd1a1522ea372390783d72cc23fedf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
静态 Public 属性</h2></td></tr>
<tr class="memitem:ac3fced48d823eb9527c54a34afaa2e03"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTAT_1_1mpi__t.html">mpi_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTAT_1_1Tensor.html#ac3fced48d823eb9527c54a34afaa2e03">mpi</a></td></tr>
<tr class="separator:ac3fced48d823eb9527c54a34afaa2e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><h3>template&lt;typename ScalarType = double, typename Symmetry = NoSymmetry, typename Name = DefaultName&gt;<br />
struct TAT::Tensor&lt; ScalarType, Symmetry, Name &gt;</h3>

<p>张量类型 </p>
<p>张量类型中含有元信息和数据两部分. 元信息包括秩, 以及秩个边 每个边含有一个Name信息以及形状信息, 对于无对称性的张量, 边的形状使用一个数字描述, 即此边的维度. 对于其他类型的对称性, 边的形状为一个该类型对称性(应该是该对称性的量子数, 这里简称对称性)到数的映射, 表示某量子数下的维度. 而张量数据部分为若干个秩维矩块, 对于无对称性张量, 仅有唯一一个矩块.</p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScalarType</td><td>张量内的标量类型 </td></tr>
    <tr><td class="paramname">Symmetry</td><td>张量所满足的对称性 </td></tr>
    <tr><td class="paramname">Name</td><td>张量的边的名称类型 </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="afaf08baeb2eed70e2f64e7af12dfeb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf08baeb2eed70e2f64e7af12dfeb8a">&#9670;&nbsp;</a></span>EdgeInfoForGetItem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> =  std::conditional_t&lt;std::is_same_v&lt;Symmetry, <a class="el" href="structTAT_1_1NoSymmetry.html">NoSymmetry</a>&gt;, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, std::tuple&lt;Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac499e258364f1d6fe53b081cf837648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac499e258364f1d6fe53b081cf837648b">&#9670;&nbsp;</a></span>EdgeInfoWithArrowForExpand</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html#ac499e258364f1d6fe53b081cf837648b">EdgeInfoWithArrowForExpand</a> =  std::conditional_t&lt; std::is_same_v&lt;Symmetry, <a class="el" href="structTAT_1_1NoSymmetry.html">NoSymmetry</a>&gt;, std::tuple&lt;<a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>&gt;, std::conditional_t&lt;<a class="el" href="group__Symmetry.html#gaa34e28a8b930984824c1825b840078e7">is_fermi_symmetry_v</a>&lt;Symmetry&gt;, std::tuple&lt;<a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a>, Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>&gt;, std::tuple&lt;Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb633a8b129a8c1f2b2b0caf5659815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb633a8b129a8c1f2b2b0caf5659815">&#9670;&nbsp;</a></span>MapIteratorList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html#a1eb633a8b129a8c1f2b2b0caf5659815">MapIteratorList</a> =  std::vector&lt;typename <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt;Symmetry&gt;::edge_map::const_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a529084aace9257dd27b0b61bde589888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529084aace9257dd27b0b61bde589888">&#9670;&nbsp;</a></span>name_valid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html#a529084aace9257dd27b0b61bde589888">name_valid</a> =  std::enable_if_t&lt;<a class="el" href="group__Name.html#ga8ebee51d36dc7cad94d0f8dce6242b9a">is_name_v</a>&lt;Name&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cc15c9afe143966029c1d0dc8fa6f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc15c9afe143966029c1d0dc8fa6f91">&#9670;&nbsp;</a></span>scalar_valid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html#a9cc15c9afe143966029c1d0dc8fa6f91">scalar_valid</a> =  std::enable_if_t&lt;<a class="el" href="group__Miscellaneous.html#ga0d9bbe7f873167b6bfbd5d6a9569f8c2">is_scalar_v</a>&lt;ScalarType&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ae719096b85159cda723101729ee703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae719096b85159cda723101729ee703">&#9670;&nbsp;</a></span>SingularType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html#a8ae719096b85159cda723101729ee703">SingularType</a> =  <a class="el" href="structTAT_1_1Singular.html">Singular</a>&lt;ScalarType, Symmetry, Name&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04b37643797ad7da56f258c2996a4135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b37643797ad7da56f258c2996a4135">&#9670;&nbsp;</a></span>symmetry_valid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html#a04b37643797ad7da56f258c2996a4135">symmetry_valid</a> =  std::enable_if_t&lt;<a class="el" href="group__Symmetry.html#ga77e4fa70b8c586c3f434630a658e1378">is_symmetry_v</a>&lt;Symmetry&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a249f71a6068ebf0932c6566e18c3e11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249f71a6068ebf0932c6566e18c3e11b">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Name &gt;&#160;</td>
          <td class="paramname"><em>names_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structTAT_1_1Edge.html">Edge</a>&lt; Symmetry &gt;&gt;&#160;</td>
          <td class="paramname"><em>edges_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>auto_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据张量边的名称和形状构造张量, 分块将自动根据对称性进行处理 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">names_init</td><td>边的名称 </td></tr>
    <tr><td class="paramname">edges_init</td><td>边的形状 </td></tr>
    <tr><td class="paramname">auto_reverse</td><td>费米对称性是否自动根据是否有负值整个反转 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Core.html" title="记录了张量的核心数据的类型, 核心数据指的是除了角标名称之外的信息, 包括边的形状, 以及张量内本身的数据">Core</a> </dd></dl>

</div>
</div>
<a id="a7a99ba8f4a7a6a7e1185b6fac04cbb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a99ba8f4a7a6a7e1185b6fac04cbb58">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename Int  = Size, typename  = std::enable_if_t&lt;std::is_same_v&lt;Symmetry, NoSymmetry&gt; &amp;&amp; !std::is_same_v&lt;Int, Edge&lt;Symmetry&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Name &gt;&#160;</td>
          <td class="paramname"><em>names_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Int &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7be591e974161d7c1b5a94082abb937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7be591e974161d7c1b5a94082abb937">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44cbc74cf19e0679da158385dc3eaa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cbc74cf19e0679da158385dc3eaa0e">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0eb853d59666d3086dfe4044521d8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0eb853d59666d3086dfe4044521d8e8">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d423525b08fa4b1624435798c2be80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d423525b08fa4b1624435798c2be80d">&#9670;&nbsp;</a></span>~Tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::~<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4804ab139acbaa19d5efb0b033653e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4804ab139acbaa19d5efb0b033653e71">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>创建秩为零的张量 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>秩为零的张量拥有的唯一一个元素的值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a4ce420223565a0c04d296dfa865ae21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce420223565a0c04d296dfa865ae21a">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ScalarType &amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5af47d0d4040ad64017c416f449a67cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af47d0d4040ad64017c416f449a67cf">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ScalarType&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取张量中某个分块内的某个元素 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>分块每个子边对应的对称性值以及元素在此子边上的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>position对于无对称性张量, 为边名到维度的映射表, 对于有对称性的张量, 是边名到对称性和相应维度的映射表 </dd></dl>

</div>
</div>
<a id="a9b5d2765c5e944925af511d75c5a7690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5d2765c5e944925af511d75c5a7690">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::barrier</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mpi进程间同步 </p>

</div>
</div>
<a id="a83c795d887c0c0a8df0839395f391ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c795d887c0c0a8df0839395f391ab6">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, Symmetry &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>{}</code></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8d8eca0c4f84479cce88768038592d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d8eca0c4f84479cce88768038592d9">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, Symmetry &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>{}</code></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取张量的某个分块 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>分块每个子边对应的对称性值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>一个不可变的一维数组 </dd></dl>
<dl class="section see"><dt>参见</dt><dd>get_block_for_get_item </dd></dl>

</div>
</div>
<a id="a6cd35ca572f1bec93ba43b4a9de5e69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd35ca572f1bec93ba43b4a9de5e69d">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::broadcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>从root进程分发张量, 使用简单的树形分发, 必须所有进程一起调用这个函数 </p>

</div>
</div>
<a id="ab1e8b48602667685790b72681050af1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e8b48602667685790b72681050af1c">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::conjugate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>生成张量的共轭张量 </p>
<dl class="section note"><dt>注解</dt><dd>如果为对称性张量, 量子数取反, 如果为费米张量, 箭头取反, 如果为复张量, 元素取共轭 </dd></dl>

</div>
</div>
<a id="a4cebe372f267460b8d0a558e2db7139a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cebe372f267460b8d0a558e2db7139a">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ScalarType &amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24d53d8dd85af8c4a0ee21fbc8dd6b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d53d8dd85af8c4a0ee21fbc8dd6b41">&#9670;&nbsp;</a></span>const_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::const_block </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, Symmetry &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>{}</code></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a246a14a49fc37102d2b184d4cc08c11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246a14a49fc37102d2b184d4cc08c11b">&#9670;&nbsp;</a></span>contract() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename OtherScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; OtherScalarType, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::tuple&lt; Name, Name &gt;&gt;&#160;</td>
          <td class="paramname"><em>contract_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada0abaf67e239dc3e74a83aafdf31c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0abaf67e239dc3e74a83aafdf31c3b">&#9670;&nbsp;</a></span>contract() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::tuple&lt; Name, Name &gt;&gt;&#160;</td>
          <td class="paramname"><em>contract_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>两个张量的缩并运算 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor_1</td><td>参与缩并的第一个张量 </td></tr>
    <tr><td class="paramname">tensor_2</td><td>参与缩并的第二个张量 </td></tr>
    <tr><td class="paramname">contract_names</td><td>两个张量将要缩并掉的边的名称 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>缩并后的张量 </dd></dl>

</div>
</div>
<a id="afe3ee11efb23ff4d93e6a565d607cbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3ee11efb23ff4d93e6a565d607cbfe">&#9670;&nbsp;</a></span>contract() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType1 , typename ScalarType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType1, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType2, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::tuple&lt; Name, Name &gt;&gt;&#160;</td>
          <td class="paramname"><em>contract_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9d58b022a6f1eaa0dfb74dcb145eb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d58b022a6f1eaa0dfb74dcb145eb31">&#9670;&nbsp;</a></span>contract_all_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::contract_all_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>张量与自己的共轭进行尽可能的缩并 </p>
<dl class="section return"><dt>返回</dt><dd>缩并后的结果 </dd></dl>

</div>
</div>
<a id="a99633cbb2776da691ad804a23f8e7d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99633cbb2776da691ad804a23f8e7d99">&#9670;&nbsp;</a></span>contract_all_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::contract_all_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将一个张量与另一个张量的所有相同名称的边进行缩并 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另一个张量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>缩并后的结果 </dd></dl>

</div>
</div>
<a id="a9d94cc5a258afdf3b256779df8a8bd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d94cc5a258afdf3b256779df8a8bd9b">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>张量的复制, 默认的赋值和复制初始化不会拷贝数据，而会共用core </p>
<dl class="section return"><dt>返回</dt><dd>复制的结果 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor.html#aadd1a1522ea372390783d72cc23fedf2" title="张量中出了边名称外的其他数据">core</a> </dd></dl>

</div>
</div>
<a id="a4df7b1315f2abd7065ef9f2053ee9a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df7b1315f2abd7065ef9f2053ee9a7a">&#9670;&nbsp;</a></span>edge_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
<div class="memtemplate">
template&lt;bool split_edge_is_pointer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::edge_operator </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>rename_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Name, std::vector&lt; std::tuple&lt; Name, <a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a>&lt; Symmetry, split_edge_is_pointer &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>split_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>reversed_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Name, std::vector&lt; Name &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>merge_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Name &gt;&#160;</td>
          <td class="paramname"><em>new_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apply_parity</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::set&lt; Name &gt;, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>parity_exclude_name</em> = <code>{{{},&#160;{},&#160;{},&#160;{}}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Name, std::map&lt; Symmetry, <a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_and_symmetries_to_cut_before_all</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对张量的边进行操作的中枢函数, 对边依次做重命名, 分裂, 费米箭头取反, 合并, 转置的操作, </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rename_map</td><td>重命名边的名称的映射表 </td></tr>
    <tr><td class="paramname">split_map</td><td>分裂一些边的数据, 需要包含分裂后边的形状, 不然分裂不唯一 </td></tr>
    <tr><td class="paramname">reversed_name</td><td>将要取反费米箭头的边的名称列表 </td></tr>
    <tr><td class="paramname">merge_map</td><td>合并一些边的名称列表 </td></tr>
    <tr><td class="paramname">new_names</td><td>最后进行的转置操作后的边的名称顺序列表 </td></tr>
    <tr><td class="paramname">apply_parity</td><td>控制费米对称性中费米性质产生的符号是否应用在结果张量上的默认行为 </td></tr>
    <tr><td class="paramname">parity_exclude_name</td><td>是否产生符号这个问题上行为与默认行为相反的操作的边的名称, 四部分分别是split, reverse, reverse_before_merge, merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>进行了一系列操作后的结果张量 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>反转不满足和合并操作的条件时, 将在合并前再次反转需要反转的边, 方向对齐第一个有方向的边 </dd>
<dd>
因为费米箭头在反转和合并分裂时会产生半个符号, 所以需要扔给一方张量, 另一方张量不变号 </dd>
<dd>
但是转置部分时产生一个符号的, 所以这一部分无视apply_parity </dd>
<dd>
本函数对转置外不标准的腿的输入是脆弱的 </dd></dl>

</div>
</div>
<a id="ad8f4ac89efc12b4afdfbe6fb12cb781b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f4ac89efc12b4afdfbe6fb12cb781b">&#9670;&nbsp;</a></span>edge_rename()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::edge_rename </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对张量边的名称进行重命名 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>重命名方案的映射表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>仅仅改变了边的名称的张量, 与原张量共享Core </dd></dl>
<dl class="section note"><dt>注解</dt><dd>虽然功能蕴含于edge_operator中, 但是edge_rename操作很常用, 所以并没有调用会稍微慢的edge_operator, 而是实现一个小功能的edge_rename </dd></dl>

</div>
</div>
<a id="acad907b1894ad6b0e54b92e3c2f28574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad907b1894ad6b0e54b92e3c2f28574">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::expand </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#ac499e258364f1d6fe53b081cf837648b">EdgeInfoWithArrowForExpand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>old_name</em> = <code><a class="el" href="structTAT_1_1InternalName.html">InternalName</a>&lt;Name&gt;::No_Old_Name</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2f426b740f06990a2decc2213413de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f426b740f06990a2decc2213413de5">&#9670;&nbsp;</a></span>exponential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::exponential </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::tuple&lt; Name, Name &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>看作矩阵后求出矩阵指数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>边的配对方案 </td></tr>
    <tr><td class="paramname">step</td><td>展开近似的次数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5065992828c0a3cb6b8358ea0adbd4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5065992828c0a3cb6b8358ea0adbd4fc">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::identity </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::tuple&lt; Name, Name &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>生成相同形状的单位张量 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>看作矩阵时边的配对方案 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a45b860499d4eaa7829efd3bcbdb1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a45b860499d4eaa7829efd3bcbdb1e9">&#9670;&nbsp;</a></span>is_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1is__scalar.html">is_scalar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67773ad17527d10e1129478340cda72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67773ad17527d10e1129478340cda72e">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a202ef1071a4e51b6344395ffbad6f1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202ef1071a4e51b6344395ffbad6f1b8">&#9670;&nbsp;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adccf842a212e8fb6b64cdf6585d2619e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccf842a212e8fb6b64cdf6585d2619e">&#9670;&nbsp;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6b84a6f099ca0193a0ad6e9e8e04415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b84a6f099ca0193a0ad6e9e8e04415">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Transform &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>对张量的每个数据元素做同样的非原地的变换 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>变换的函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>张量自身 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>参见std::transform </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor.html#acba0ec0802ec95a255a99bc42d94dd1f" title="对张量的每个数据元素做同样的原地的变换">transform</a> </dd></dl>

</div>
</div>
<a id="ae7c9939fc28077a7aaabc7da37aeab66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c9939fc28077a7aaabc7da37aeab66">&#9670;&nbsp;</a></span>merge_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::merge_edge </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; Name, std::vector&lt; Name &gt;&gt;&#160;</td>
          <td class="paramname"><em>merge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apply_parity</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>parity_exclude_name_merge</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>parity_exclude_name_reverse</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>合并张量的一些边 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">merge</td><td>合并的边的名称的映射表 </td></tr>
    <tr><td class="paramname">apply_parity</td><td>是否应用合并边产生的符号 </td></tr>
    <tr><td class="paramname">parity_exclude_name_merge</td><td>merge过程中与apply_parity不符的例外 </td></tr>
    <tr><td class="paramname">parity_exclude_name_reverse</td><td>merge前不得不做的reverse过程中与apply_parity不符的例外 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>合并边后的结果张量 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>合并前转置的策略是将一组合并的边按照合并时的顺序移动到这组合并边中最后的一个边前, 其他边位置不变 </dd></dl>

</div>
</div>
<a id="aa827a3d73c6b1517abf7e5c1f472561f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa827a3d73c6b1517abf7e5c1f472561f">&#9670;&nbsp;</a></span>multiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::multiple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html#a8ae719096b85159cda723101729ee703">SingularType</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>division</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>张量缩并上SVD产生的奇异值数据, 就地操作 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>奇异值 </td></tr>
    <tr><td class="paramname">name</td><td>张量与奇异值缩并的边名 </td></tr>
    <tr><td class="paramname">direction</td><td>奇异值是含有一个方向的, SVD的结果中U还是V将与S相乘在这里被选定 </td></tr>
    <tr><td class="paramname">division</td><td>如果为真, 则进行除法而不是乘法 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>缩并的结果 </dd></dl>

</div>
</div>
<a id="a6cb81dfbd5808d32766b0acf5a60a9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb81dfbd5808d32766b0acf5a60a9aa">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;int p = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Miscellaneous.html#ga03fb813e3f2c8c1633ebe103894051a3">real_base_t</a>&lt;ScalarType&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>求张量的模, 是拉平看作向量的模, 并不是矩阵模之类的东西 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">p</td><td>所求的模是张量的p-模, 如果p=-1, 则意味着最大模即p=inf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>标量类型的模 </dd></dl>

</div>
</div>
<a id="a24856542d03837f09da3a2f2efd78c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24856542d03837f09da3a2f2efd78c67">&#9670;&nbsp;</a></span>one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::one </td>
          <td>(</td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Name &gt;&#160;</td>
          <td class="paramname"><em>names_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Symmetry &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_symmetry</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_arrow</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>创建高秩但是元素只有一个的张量 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>秩为零的张量拥有的唯一一个元素的值 </td></tr>
    <tr><td class="paramname">names_init</td><td>边的名称 </td></tr>
    <tr><td class="paramname">edge_symmetry</td><td>如果系统含有对称性, 则需要设置此值 </td></tr>
    <tr><td class="paramname">edge_arrow</td><td>如果系统对称性为fermi对称性, 则需要设置此值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab836bd75946c187a1cc2acbaf1921cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab836bd75946c187a1cc2acbaf1921cb6">&#9670;&nbsp;</a></span>operator ScalarType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::operator ScalarType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>秩为一的张量转化为其中唯一一个元素的标量类型 </p>

</div>
</div>
<a id="a2e1ca6a58056b952a50e3238ba2a533c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1ca6a58056b952a50e3238ba2a533c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6470e216cc48981c2ebf754e3a83f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6470e216cc48981c2ebf754e3a83f9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a342a8acb21bfa6dcd6c45a4b4efc3145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342a8acb21bfa6dcd6c45a4b4efc3145">&#9670;&nbsp;</a></span>qr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor_1_1qr__result.html">qr_result</a> <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::qr </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>free_name_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_name_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>common_name_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>common_name_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对张量进行qr分解 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">free_name_direction</td><td>free_name_set取的方向, 为'Q'或'R' </td></tr>
    <tr><td class="paramname">free_name_set</td><td>qr分解中某一侧的边的名称集合 </td></tr>
    <tr><td class="paramname">common_name_q</td><td>分解后q新产生的边的名称 </td></tr>
    <tr><td class="paramname">common_name_r</td><td>分解后r新产生的边的名称 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>qr的结果 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor_1_1qr__result.html" title="张量qr的结果类型">qr_result</a> </dd></dl>

</div>
</div>
<a id="ad208b0c8577ff1d5fed6a2b2c945698e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad208b0c8577ff1d5fed6a2b2c945698e">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destination调用此函数, 从source接受一个张量 </p>

</div>
</div>
<a id="ab2117eb5c897ed1ac6a42807966e372d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2117eb5c897ed1ac6a42807966e372d">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>向root进程reduce张量, 使用简单的树形reduce, 必须所有进程一起调用这个函数, 最后root进程返回全部reduce的结果, 其他进程为中间结果一般无意义 </p>

</div>
</div>
<a id="abbe401ff6d00b18a4e110e4e6b8aa3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe401ff6d00b18a4e110e4e6b8aa3aa">&#9670;&nbsp;</a></span>reverse_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::reverse_edge </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>reversed_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apply_parity</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>parity_exclude_name</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将费米张量的一些边进行反转 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reversed_name</td><td>反转的边的集合 </td></tr>
    <tr><td class="paramname">apply_parity</td><td>是否应用反转产生的符号 </td></tr>
    <tr><td class="paramname">parity_exclude_name</td><td>与apply_parity行为相反的边名集合 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>反转后的结果张量 </dd></dl>

</div>
</div>
<a id="a8419fd382c3d74ceafb7b9b06e0214ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8419fd382c3d74ceafb7b9b06e0214ca">&#9670;&nbsp;</a></span>same_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::same_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>产生一个与自己形状一样的张量 </p>
<dl class="section return"><dt>返回</dt><dd>一个未初始化数据内容的张量 </dd></dl>

</div>
</div>
<a id="ab409a6f2d8f3ea1812b65a240ba5280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab409a6f2d8f3ea1812b65a240ba5280c">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>source调用此函数, 向destination发送一个张量 </p>

</div>
</div>
<a id="ae4cdde69a41a39bdd528983f775ce9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cdde69a41a39bdd528983f775ce9a1">&#9670;&nbsp;</a></span>send_receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::send_receive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>像简单类型一样使用mpi但send和receive, 调用后, 一个destination返回source调用时输入tensor, 其他进程返回空张量 </p>

</div>
</div>
<a id="ac7fa382fd250903d72418b8e10ed4a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fa382fd250903d72418b8e10ed4a65">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Generator &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>通过一个生成器设置一个张量内的数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>生成器, 一般来说是一个无参数的函数, 返回值为标量, 多次调用填充张量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>张量自身 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor.html#acba0ec0802ec95a255a99bc42d94dd1f" title="对张量的每个数据元素做同样的原地的变换">transform</a> </dd></dl>

</div>
</div>
<a id="a2c908557416bb3b3c72896320aa30106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c908557416bb3b3c72896320aa30106">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Generator &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a626e84e32ab8019597c60ada6f9a45ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626e84e32ab8019597c60ada6f9a45ea">&#9670;&nbsp;</a></span>shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::shrink </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>new_name</em> = <code><a class="el" href="structTAT_1_1InternalName.html">InternalName</a>&lt;Name&gt;::No_New_Name</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a>&#160;</td>
          <td class="paramname"><em>arrow</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace1791bdc2285cf186be58d30d7c9f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1791bdc2285cf186be58d30d7c9f42">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Name, <a class="el" href="structTAT_1_1Tensor.html#afaf08baeb2eed70e2f64e7af12dfeb8a">EdgeInfoForGetItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>new_name</em> = <code><a class="el" href="structTAT_1_1InternalName.html">InternalName</a>&lt;Name&gt;::No_New_Name</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Miscellaneous.html#ga78326bee7cc963cd2d165718de5c0465">Arrow</a>&#160;</td>
          <td class="paramname"><em>arrow</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2c9d5865a9866a31a44db38b6aaf5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c9d5865a9866a31a44db38b6aaf5b8">&#9670;&nbsp;</a></span>split_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::split_edge </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; Name, std::vector&lt; std::tuple&lt; Name, <a class="el" href="structTAT_1_1BoseEdge.html">BoseEdge</a>&lt; Symmetry &gt;&gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apply_parity</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>parity_exclude_name_split</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>分裂张量的一些边 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>分裂的边的名称的映射表 </td></tr>
    <tr><td class="paramname">apply_parity</td><td>是否应用分裂边产生的符号 </td></tr>
    <tr><td class="paramname">parity_exclude_name_split</td><td>split过程中与apply_parity不符的例外 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>分裂边后的结果张量 </dd></dl>

</div>
</div>
<a id="a913bb31e5ca738fb74f646e5512a4c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913bb31e5ca738fb74f646e5512a4c36">&#9670;&nbsp;</a></span>summary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::summary </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d89e92d6d758c7bfac52e84f3265f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d89e92d6d758c7bfac52e84f3265f20">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::<a class="el" href="structTAT_1_1Tensor_1_1svd__result.html">svd_result</a> <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::svd </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; Name &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_name_set_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>common_name_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>common_name_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>&#160;</td>
          <td class="paramname"><em>cut</em> = <code><a class="el" href="group__Miscellaneous.html#gac705eedd6237ac6373746e8d473fef14">Size</a>(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对张量进行svd分解 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">free_name_set_u</td><td>svd分解中u的边的名称集合 </td></tr>
    <tr><td class="paramname">common_name_u</td><td>分解后u新产生的边的名称 </td></tr>
    <tr><td class="paramname">common_name_v</td><td>分解后v新产生的边的名称 </td></tr>
    <tr><td class="paramname">cut</td><td>需要截断的维度数目 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>svd的结果 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor_1_1svd__result.html" title="张量svd的结果类型">svd_result</a> </dd></dl>
<dl class="section note"><dt>注解</dt><dd>对于对称性张量, S需要有对称性, S对称性与V的公共边配对, 与U的公共边相同 </dd></dl>

</div>
</div>
<a id="a070c446e688bad4dd586b4e5f23ebb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070c446e688bad4dd586b4e5f23ebb6c">&#9670;&nbsp;</a></span>test() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::test </td>
          <td>(</td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>first</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将张量内的数据设置为便于测试的值 </p>
<dl class="section return"><dt>返回</dt><dd>张量自身 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor.html#ac7fa382fd250903d72418b8e10ed4a65" title="通过一个生成器设置一个张量内的数据">set</a> </dd></dl>

</div>
</div>
<a id="a0fe4f7437b71de7367ca2623a2111aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe4f7437b71de7367ca2623a2111aaa">&#9670;&nbsp;</a></span>test() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::test </td>
          <td>(</td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>first</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab102bd3898b58fff24b10ed07f3221e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab102bd3898b58fff24b10ed07f3221e6">&#9670;&nbsp;</a></span>to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename OtherScalarType , typename  = std::enable_if_t&lt;is_scalar_v&lt;OtherScalarType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;OtherScalarType, Symmetry, Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>不同标量类型的张量之间的转换函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherScalarType</td><td>目标张量的基础标量类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>转换后的张量 </dd></dl>

</div>
</div>
<a id="a0a076f5dddae84960769976d67e136b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a076f5dddae84960769976d67e136b8">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::trace </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::tuple&lt; Name, Name &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>trace_names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acba0ec0802ec95a255a99bc42d94dd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba0ec0802ec95a255a99bc42d94dd1f">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">Transform &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>对张量的每个数据元素做同样的原地的变换 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>变换的函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>张量自身 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>参见std::transform </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor.html#aa6b84a6f099ca0193a0ad6e9e8e04415" title="对张量的每个数据元素做同样的非原地的变换">map</a> </dd></dl>

</div>
</div>
<a id="a9cf93a852d354ee03e3ae33e278ec396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf93a852d354ee03e3ae33e278ec396">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<div class="memtemplate">
template&lt;typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">Transform &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a439e664b9580d6514c65f7f866f288d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439e664b9580d6514c65f7f866f288d2">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt; ScalarType, Symmetry, Name &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Name &gt;&#160;</td>
          <td class="paramname"><em>target_names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对张量进行转置 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_names</td><td>转置后的目标边的名称顺序 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>转置后的结果张量 </dd></dl>

</div>
</div>
<a id="a25052984c028c2913d77fc0ed079f02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25052984c028c2913d77fc0ed079f02d">&#9670;&nbsp;</a></span>zero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将张量内的数据全部设置为零 </p>
<dl class="section return"><dt>返回</dt><dd>张量自身 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Tensor.html#ac7fa382fd250903d72418b8e10ed4a65" title="通过一个生成器设置一个张量内的数据">set</a> </dd></dl>

</div>
</div>
<a id="ae63a2323a01a71dda38b8856cb5a532b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63a2323a01a71dda38b8856cb5a532b">&#9670;&nbsp;</a></span>zero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a>&lt;ScalarType, Symmetry, Name&gt;&amp;&amp; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="aadd1a1522ea372390783d72cc23fedf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd1a1522ea372390783d72cc23fedf2">&#9670;&nbsp;</a></span>core</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structTAT_1_1Core.html">Core</a>&lt;ScalarType, Symmetry&gt; &gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::core</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>张量中出了边名称外的其他数据 </p>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1Core.html" title="记录了张量的核心数据的类型, 核心数据指的是除了角标名称之外的信息, 包括边的形状, 以及张量内本身的数据">Core</a> </dd></dl>
<dl class="section note"><dt>注解</dt><dd>因为重命名边的操作很常见, 为了避免复制, 使用shared_ptr封装Core </dd></dl>

</div>
</div>
<a id="ac3fced48d823eb9527c54a34afaa2e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fced48d823eb9527c54a34afaa2e03">&#9670;&nbsp;</a></span>mpi</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType , typename Symmetry , typename Name &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTAT_1_1mpi__t.html">mpi_t</a> <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::mpi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>参见</dt><dd><a class="el" href="structTAT_1_1mpi__t.html" title="一个mpi handler, 会在构造和析构时自动调用MPI_Init和MPI_Finalize, 且会获取Size和Rank信息">mpi_t</a> </dd></dl>

</div>
</div>
<a id="ad4dca3481df8511db539e12297b8dc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dca3481df8511db539e12297b8dc90">&#9670;&nbsp;</a></span>name_to_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Name, <a class="el" href="group__Miscellaneous.html#ga62eb09d4bc76da9469d3a43882ca295a">Rank</a>&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::name_to_index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>张量边名称到边的序号的映射表 </p>
<dl class="section note"><dt>注解</dt><dd>虽然可能因为内存分配效率会不高, 但是在边很多的时候会很有用, 比如费米张量的w(s)处 </dd></dl>

</div>
</div>
<a id="aff3fe646de6b8d94251e0d8096cad12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3fe646de6b8d94251e0d8096cad12b">&#9670;&nbsp;</a></span>names</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double, typename Symmetry  = NoSymmetry, typename Name  = DefaultName&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Name&gt; <a class="el" href="structTAT_1_1Tensor.html">TAT::Tensor</a>&lt; ScalarType, Symmetry, Name &gt;::names</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>张量的边的名称 </p>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="group__Name.html" title="张量的边的名称">Name</a> </dd></dl>

</div>
</div>
<hr/>该结构体的文档由以下文件生成:<ul>
<li>include/TAT/<a class="el" href="tensor_8hpp_source.html">tensor.hpp</a></li>
<li>include/TAT/<a class="el" href="contract_8hpp_source.html">contract.hpp</a></li>
<li>include/TAT/<a class="el" href="edge__miscellaneous_8hpp_source.html">edge_miscellaneous.hpp</a></li>
<li>include/TAT/<a class="el" href="edge__operator_8hpp_source.html">edge_operator.hpp</a></li>
<li>include/TAT/<a class="el" href="get__item_8hpp_source.html">get_item.hpp</a></li>
<li>include/TAT/<a class="el" href="io_8hpp_source.html">io.hpp</a></li>
<li>include/TAT/<a class="el" href="mpi_8hpp_source.html">mpi.hpp</a></li>
<li>include/TAT/<a class="el" href="qr_8hpp_source.html">qr.hpp</a></li>
<li>include/TAT/<a class="el" href="shrink__and__expand_8hpp_source.html">shrink_and_expand.hpp</a></li>
<li>include/TAT/<a class="el" href="svd_8hpp_source.html">svd.hpp</a></li>
<li>include/TAT/<a class="el" href="tensor__miscellaneous_8hpp_source.html">tensor_miscellaneous.hpp</a></li>
<li>include/TAT/<a class="el" href="trace_8hpp_source.html">trace.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceTAT.html">TAT</a></li><li class="navelem"><a class="el" href="structTAT_1_1Tensor.html">Tensor</a></li>
    <li class="footer">生成于 2020年 十二月 9日 星期三 01:49:45 , 为 TAT使用 
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
